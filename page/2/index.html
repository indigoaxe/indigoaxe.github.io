<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="IndigoAxe">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="IndigoAxe">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="IndigoAxe">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>IndigoAxe</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">IndigoAxe</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/18/geekband-stlyu-fan-xing-bian-cheng-shang-ke-bi-ji-part-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Tang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IndigoAxe">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/18/geekband-stlyu-fan-xing-bian-cheng-shang-ke-bi-ji-part-1/" itemprop="url">[GeekBand] STL与泛型编程上课笔记 part.1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-18T00:47:44+08:00">
                2018-06-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="#1">1. 函数模板与类模板</a><br><a href="#2">2. Traits</a><br><a href="#3">3. 迭代器与容器</a>  </p>
<hr>
<h4 id="1">函数模板与类模板</h4>

<p>关于模板，之前课程的内容已经覆盖了不少。这方面内容，在之前的笔记也有讨论：<br><a href="http://runalex.com/geekband-cmian-xiang-dui-xiang-gao-ji-bian-cheng-xia-shang-ke-bi-ji-part-1/" target="_blank" rel="noopener">C++面向对象高级编程（下）上课笔记 part.1</a></p>
<p>下面是关于函数模板的总结：</p>
<blockquote>
<p>对于不同的实参型别，模板函数定义了一族函数<br>  当传递模板实参的时候，函数目标根据实参的型别进行实例化<br>可以显示指定模板的实参型别<br>函数模板可以重载<br>当重载函数模板时，将改变限制在：显示指定模板参数<br>所有的重载版本的声明必须位于他们被调用的位置之前  </p>
</blockquote>
<p>类模板的总结：</p>
<blockquote>
<p>模板类的性质是，有一个或多个型别未被指定<br>  要使用一个模板类，就传入具体的型别作为实参；编译器会基于该型别来实例化类模板<br>  对于类模板而言，只有被调用到的成员函数才会被实例化<br>  类模板可以用特定的型别特化（specialization）<br>  类模板也可以用特定的型别偏特化（partial specialization）<br>  类模板参数可以有默认值  </p>
</blockquote>
<p>总的来说，模板是C++中用于支持泛型编程的一种特性。泛型编程（Generic programming）是一种编程方法，这种方法将型别（type）以一种<strong>to-be-specified-later</strong>的方式给出，等到需要调用的时候，再以参数范式，通过具体的、特定的型别去实例化（instantiate）一个具体的方法或对象。</p>
<hr>
<h4 id="2">Traits</h4>

<p>Traits是C++里的一种用于支持泛型编程的技术。通过traits class，我们可以让我们编写的模板更加通用。当我们用去实例化模板时，会有一些特殊的实例化场景。在这些场景下面，我们的模板的功能可能会不足或是无法使用。而traits的作用就是解决这些特殊场景下的泛化问题。这项技术在STL库中有大量的使用，是一项非常有用的技术。</p>
<p>wiki上对traits class的定义是：</p>
<blockquote>
<p>traits class是个类模板，在不修改一个实体（通常是数据类型或常量）的前提下，把属性和方法关联到一个编译时的实体。在c++中的具体实现方式是：首先定义一个类模板，然后进行显式特化或进行相关类型的部分特化。</p>
</blockquote>
<p>下面我们根据例子来了解Traits的使用。<br>首先我们有一个函数用来计算一个数组的总和：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt; inline T Sigma(const T const* start, const T const *end)&#123;</span><br><span class="line">    T total = T(); // SupposeT() creates a zero value.</span><br><span class="line">    while(start! = end)&#123;</span><br><span class="line">        total += *start++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数乍一看很完美，但实际上有很大的问题。它容易出现数据溢出。<br>当我们这样使用时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char str[] = &quot;abc&quot;;</span><br><span class="line">std::size_t len = strlen(str);</span><br><span class="line">char* start = str;</span><br><span class="line">char* end = str + len;</span><br><span class="line">printf(&quot;Sigma(str)=%d\n&quot;,Sigma(start,end));</span><br></pre></td></tr></table></figure>

<p>正确的结果应该是97+98+99=294，然而实际上我们将会得到0x26。这是因为返回的参数类型也是char，而char的最大值是255。<br>这个问题的解决办法就是为每个Sigma函数的参数型别T创建一种关联，而保存这些关联的类就是traits class：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt; class  SigmaTraits &#123;&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;</span><br><span class="line">class SigmaTraits &lt;char&gt; &#123;</span><br><span class="line">    public: typedef int returnType;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;</span><br><span class="line">class SigmaTraits &lt;int&gt; &#123;</span><br><span class="line">    public: typedef long returnType; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们针对每一种型别，都制定了相应的returnType。通过设置相应的返回值，我们可以避免出现数据溢出的情况。现在Sigma函数可以改编为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">typename SigmaTraits&lt;T&gt;::returnType sigma(T* start, T* end)&#123;</span><br><span class="line">    typedef typename SigmaTraits&lt;T&gt;::returnType returnType;</span><br><span class="line">    returnType total = returnType();</span><br><span class="line">    while (start != end)</span><br><span class="line">    &#123;</span><br><span class="line">        total += *start++;</span><br><span class="line">    &#125;</span><br><span class="line">    return total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3">迭代器与容器</h4>

<p><strong>迭代器</strong>是指针的泛化（generalization of pointers），本质上是对象，用来一个指向另外一个对象。在STL中，迭代器最重要的思想就是分离算法和容器，使他们之间不需要相互依赖。同时，迭代器还起到了粘合的作用，使得一种算法的实现可以运用到多种不同的容器上。</p>
<p><strong>容器</strong>顾名思义，就是用来管理某类对象的集合。网上有很多容器的详解，这里就不展开讲了。下面是主要容器的列表，<br>标准STL序列容器：vector（数组），string（数组），deque（数组），list（双向循环链表）<br>标准STL关联容器：set（红黑树），multiset（红黑树），map（红黑树），multimap（红黑树）</p>
<p>老师在讲到在利用<code>erase</code>方法删除容器成员时，有些地方讲的不是很清楚。通过网上搜索，我才明白<code>remove_if</code>的作用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v.erase(std::remove_if(</span><br><span class="line">          v.begin(),</span><br><span class="line">          v.end(),</span><br><span class="line">          ContainsString(L&apos;C++&apos;)</span><br><span class="line">  ), </span><br><span class="line">  v.end()</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>

<p>在以上的函数调用张，<code>remove_if</code>起到的作用是：在容器内，对每个元素调用<code>ConstainString</code>，如果返回<code>true</code>，那么将该元素放到容器尾部，其他元素则保持原来的顺序。最后返回一个指向最后一个未删元素的下一个位置的迭代器。实际上该函数并没有真正将其删除，而通过<code>erase</code>，我们才能将放在末尾的那些所需要删除的元素真正的去除掉。</p>
<p>remove_if的<a href="http://en.cppreference.com/w/cpp/algorithm/remove" target="_blank" rel="noopener">原理</a>：</p>
<blockquote>
<p>Removing is done by shifting (by means of move assignment) the elements in the range in such a way that the elements that are not to be removed appear in the beginning of the range. Relative order of the elements that remain is preserved and the physical size of the container is unchanged. Iterators pointing to an element between the new logical end and the physical end of the range are still dereferenceable, but the elements themselves have unspecified values (as per MoveAssignable post-condition). A call to remove is typically followed by a call to a container’s erase method, which erases the unspecified values and reduces the physical size of the container to match its new logical size.</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/10/geekband-cmian-xiang-dui-xiang-gao-ji-bian-cheng-xia-shang-ke-bi-ji-part-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Tang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IndigoAxe">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/10/geekband-cmian-xiang-dui-xiang-gao-ji-bian-cheng-xia-shang-ke-bi-ji-part-2/" itemprop="url">[GeekBand] C++面向对象高级编程（下）上课笔记 part.2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-10T07:52:23+08:00">
                2018-06-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本周课程主要讨论的话题<br><a href="#1">1.  对象模型</a><br><a href="#2">2. Const</a><br><a href="#3">3. 关于new和delete</a></p>
<hr>
<p>####<a href="#1">对象模型</a><br>关于C++对象模型，有一篇博客写得很详尽，该文需要反复阅读：<a href="http://www.cnblogs.com/skynet/p/3343726.html" target="_blank" rel="noopener">http://www.cnblogs.com/skynet/p/3343726.html</a>  - C++ 对象模型 by 吴秦</p>
<p>关于C++模型，上面的文章是这么介绍的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在此模型中，non static 数据成员被放置到对象内部，static数据成员， static and nonstatic 函数成员均被放到对象之外。对于虚函数的支持则分两步完成：</span><br><span class="line"></span><br><span class="line">    1. 每一个class产生一堆指向虚函数的指针，放在表格之中。这个表格称之为虚函数表（virtual table，vtbl）。</span><br><span class="line"></span><br><span class="line">    2. 每一个对象被添加了一个指针，指向相关的虚函数表vtbl。通常这个指针被称为vptr。vptr的设定（setting）和重置（resetting）都由每一个class的**构造函数，析构函数和拷贝赋值运算符**自动完成。</span><br><span class="line"></span><br><span class="line">另外，虚函数表地址的前面设置了一个指向type_info的指针，RTTI（Run Time Type Identification）运行时类型识别是有编译器在编译器生成的特殊类型信息，包括对象继承关系，对象本身的描述，RTTI是为多态而生成的信息，所以只有具有虚函数的对象在会生成。</span><br><span class="line"></span><br><span class="line">这个模型的优点在于它的空间和存取时间的效率；缺点如下：如果应用程序本身未改变，但当所使用的类的non static数据成员添加删除或修改时，需要重新编译。</span><br></pre></td></tr></table></figure>

<p>总而言之，C++的对象模型对于虚函数的支持有两个重要的元素：vptr和vtbl。在C++对象模型中，每一个具有虚函数的对象都会至少有一个虚指针vptr（在多重继承的情况下，则一个对象会有多个vptr），并且被放在该对象内存的最前面。vtbl虚函数表就是vptr指向的内存空间，它可以被看作为一个指针数组，保存着指向虚函数的函数指针。但是与vptr不同，vtbl是每一个类只有一个。知道的这些后再看看下图，加强理解：<br><img src="/content/images/2018/06/object_model-1.png" alt></p>
<p>要理解虚函数的调用，得先了解静态绑定和动态绑定的区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">数据成员如何访问（直接取址） </span><br><span class="line">跟实际对象模型相关联，根据对象起始地址+偏移量取得。</span><br><span class="line"></span><br><span class="line">静态绑定与动态绑定  </span><br><span class="line">程序调用函数时，将使用那个可执行代码块呢？编译器负责回答这个问题。将源代码中的函数调用解析为执行特定的函数代码块被称为函数名绑定（binding，又称联编）。在C语言中，这非常简单，因为每个函数名都对应一个不同的额函数。在C++中，由于函数重载的缘故，这项任务更复杂。编译器必须查看函数参数以及函数名才能确定使用哪个函数。然而编译器可以在编译过程中完成这种绑定，这称为静态绑定（static binding），又称为早期绑定（early binding）。</span><br><span class="line"></span><br><span class="line">然而虚函数使这项工作变得更加困难。使用哪一个函数不是能在编译阶段时确定的，因为编译器不知道用户将选择哪种类型。所以，编译器必须能够在程序运行时选择正确的虚函数的代码，这被称为动态绑定（dynamic binding），又称为晚期绑定（late binding）。</span><br><span class="line"></span><br><span class="line">使用虚函数是有代价的，在内存和执行速度方面是有一定成本的，包括：</span><br><span class="line"></span><br><span class="line">1.  每个对象都将增大，增大量为存储虚函数表指针的大小；</span><br><span class="line">2.  对于每个类，编译器都创建一个虚函数地址表；</span><br><span class="line">3.  对于每个函数调用，都需要执行一项额外的操作，即到虚函数表中查找地址。</span><br><span class="line"></span><br><span class="line">虽然非虚函数比虚函数效率稍高，单不具备动态联编能力。</span><br></pre></td></tr></table></figure>

<p>此外，侯老师对动态绑定的讲解中有提到动态绑定可以看做是：<br><code>(* (p-&gt;vptr)[n])</code> 或 <code>(* p-&gt;vptr[n])</code>，以此类推虚函数调用是这样的：<code>(* p-&gt;vptr[n])(this)</code>。(注：此处的this非常重要！）</p>
<hr>
<p><a href="#2">Const</a>  </p>
<p>当成员函数的const和non-const版本同时存在，<br>const object只会（只能）调用const版本，<br>non-const object只会（只能）调用non-const版本。</p>
<p>例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// class template std::basic_string&lt;...&gt;</span><br><span class="line">// 有如下两个member functions:</span><br><span class="line"></span><br><span class="line">charT operator[] (size_type pos) const </span><br><span class="line">&#123; ...... /* 不必考虑 COW*/&#125;</span><br><span class="line"></span><br><span class="line">reference</span><br><span class="line">operator operator[] (size_type pos) </span><br><span class="line">&#123; ...... /* 必须考虑 COW*/ &#125;</span><br></pre></td></tr></table></figure>

<p>COW - Copy-On-Write 写时复制。关于写时复制，《More Effective C++》中的条款29有提到。简单的说就是：<br>在复制一个对象的时候并不是真正的把原先的对象复制到内存的另外一个位置上，而是在新对象的内存映射表中设置一个指针，指向源对象的位置，并把那块内存的Copy-On-Write位设置为1。<br>这样，在对新的对象执行读操作的时候，内存数据不发生任何变动，直接执行读操作；而在对新的对象执行写操作时，将真正的对象复制到新的内存地址中，并修改新对象的内存映射表指向这个新的位置，并在新的内存位置上执行写操作。</p>
<hr>
<p><a href="#3">关于new和delete</a></p>
<p>首先关于new，我们要知道new operator与operator new之间是有区别的。在<code>string *str = new string(&quot;hello&quot;);</code>里的new是所谓的new operator。这个操作符的行为在C++中是固定的，无法被改变。它的行为分成两步：第一步，为对象分配足够的内存空间；第二，调用该对象的constructor为其进行初始化。无论如何，new operator操作都是由这两步组成的。</p>
<p>而我们能改变的，是new operator中的第一步，即分配内存。new operator是通过调用operator new函数（通常声明为<code>void *operator new(size_t size);</code>）来进行这一操作的。operator delete也是相似的。对于operator new/delete，我们可以进行重写或重载：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void *Foo::operator new(size_t size)&#123;</span><br><span class="line">    return (Foo*)malloc(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *Foo::operator delete(void* phead, size_t size)&#123;</span><br><span class="line">    free(phead);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Operator new函数的返回类型是一个指向一块原始的、未设初始值的内存。参数size为需要分配内存的大小。我们可以重载operator new并加上新的参数，但是第一参数的类型必须总是size_t。Operator delete和delete operator之间的关系也是类似的。此外，C++中还有array版本的new和delete。关于operator new[]/delete[]的示例代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Foo *p = new Foo[N];</span><br><span class="line">// 上一句可以理解为：</span><br><span class="line">try&#123;</span><br><span class="line">    void *mem = operator new(sizeof(Foo)*N+4); //这里的4是为记录N而分配的</span><br><span class="line">    p = static_cast&lt;Foo*&gt;(mem);</span><br><span class="line">    p-&gt;Foo::Foo(); // N 次</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete []p;</span><br><span class="line">//同样的可以理解为</span><br><span class="line">p-&gt;~Foo(); // N 次</span><br><span class="line">operator delete(p);</span><br></pre></td></tr></table></figure>

<p>在重载或重写operator new的时候一定要注意内存分配操作的正确性，否则影响会很大。</p>
<p><strong>placement new</strong></p>
<p>有一种特殊的operator new，它的特殊之处在于它可以帮助你在一块已经分配好的内存上面构建对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Shape&#123;</span><br><span class="line">public:</span><br><span class="line">    Shape(int width, int high);</span><br><span class="line">    ...</span><br><span class="line">    // 标准库提供的placement new的形式</span><br><span class="line">    void* operator new(size_t size, void* start)&#123;return start;&#125;</span><br><span class="line">    //对placement new进行重载，调用方式是</span><br><span class="line">    // Shape *s = new(30) Shape;</span><br><span class="line">    void* operator new(size_t size, long extra)&#123;</span><br><span class="line">        return malloc(size+extra);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Shape * constructShapeBuffer(void *buffer, int width, int height)&#123;</span><br><span class="line">    return new(buffer) Shape(width,height); //使用了placement new</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以下示例学习如何强制调用全局函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Foo *p = ::new Foo(7);</span><br><span class="line">::delete p;</span><br><span class="line">//这样，即使Foo存在重载的成员operator new/delete，调用的仍然是全局版本的。</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/05/geekband-cmian-xiang-dui-xiang-gao-ji-bian-cheng-xia-shang-ke-bi-ji-part-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Tang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IndigoAxe">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/05/geekband-cmian-xiang-dui-xiang-gao-ji-bian-cheng-xia-shang-ke-bi-ji-part-1/" itemprop="url">[GeekBand] C++面向对象高级编程（下）上课笔记 part.1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-05T02:57:44+08:00">
                2018-06-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本周主要的内容：<br><a href="#1">1. Conversion function &amp; non-explicit one argument ctor<br>转换函数与非explicit单参数构造函数</a><br><a href="#2">2. Pointer-like &amp; function-like classes  仿指针和仿函数</a><br><a href="#3">3. Template模板</a><br><a href="#4">4. Specialization特化</a><br><a href="#5">5. 关于C++11的三个新特性</a><br><a href="#6">6. 再谈reference</a></p>
<hr>
<p>####<a href="#1">1. Conversion function &amp; non-explicit one argument ctor</a> </p>
<p><strong>Conversion function</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Fraction&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    //分母默认为1</span><br><span class="line">    Fraction(int num, int den=1) : m_numerator(num), m_denominator(den) &#123; &#125; </span><br><span class="line">    //由于是转换函数，因此不可有参数。而返回类型与函数名是对应的，如这里的double，所以返回类型也不用写。</span><br><span class="line">    //转换时不会改变类成员变量，因此需要加const。</span><br><span class="line">    operator double() const &#123; </span><br><span class="line">        return (double)(m_numerator / m_denominator);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">int m_numerator;</span><br><span class="line">int m_denominator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Fraction f(3,5);</span><br><span class="line">double d=4+f; //调用double转换函数</span><br></pre></td></tr></table></figure>

<p><strong>标准库里的转换函数使用：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//这里使用了proxy设计模式</span><br><span class="line">template&lt;class Alloc&gt;</span><br><span class="line">class vector&lt;bool, Alloc&gt;&#123;</span><br><span class="line">public:</span><br><span class="line">    typedef __bit_reference reference; //reference作为代理，替代了bool的使用。</span><br><span class="line">protected:</span><br><span class="line">    reference operator[](size type n)&#123;</span><br><span class="line">        return *(begin() +diffenece_type(n));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">... </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct __bit_reference&#123;</span><br><span class="line">    unsigned int* p;</span><br><span class="line">    unsigned int mask;</span><br><span class="line">    ...</span><br><span class="line">public:</span><br><span class="line">    operator bool() const &#123; return !(!(*p * mask));&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>non-explicit one argument ctor</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Fraction&#123;</span><br><span class="line">public:</span><br><span class="line">    // 虽然这个构造函数有两个parameter,但是调用它所必须的参数只有一个，因此，因此这是一个non-explicit-one-argument ctor</span><br><span class="line">    Fraction（int num，int den=1）：m_numerator（num），m_denominator(den) &#123;  &#125;</span><br><span class="line">    Fraction operator+(constFraction&amp; f) &#123;</span><br><span class="line">        return</span><br><span class="line">    Fraction(...);</span><br><span class="line">private:</span><br><span class="line">    int m_numerator;</span><br><span class="line">    int m_denominator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Fraction f(3,5);</span><br><span class="line">//调用non-explict ctor将4转为Fraction(4,1)，然后调用operator+</span><br><span class="line">Fraction d2 = f + 4;</span><br></pre></td></tr></table></figure>

<p>在以上的例子中，如果给<code>Fraction</code>类加上以下成员函数，会报ambiguous的error。解决方案是在non-explicit one argument ctor前加<code>explict</code>关键字，告诉编译器不要自动将4转换为Fraction(4,1)，此时将会对f调用double转换函数。==<code>explicit</code>的主要用法就在这里（构造函数的前面）。==</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">operator double() const &#123; return (double)(m_numerator / m_denominator);&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>####<a href="#2">Pointer-like &amp; function-like classes 仿指针和仿函数</a>  </p>
<p><strong>Pointer-like class</strong><br>模仿指针的使用方式，但是又加了一些功能，因此又叫智能指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//智能指针里一定有真正的指针</span><br><span class="line">//下面是简化版的智能指针</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class shared_ptr&#123;</span><br><span class="line">public:</span><br><span class="line">  //必要的操作符重载</span><br><span class="line">  T&amp; operator*()  const &#123; return *px;&#125;</span><br><span class="line">  T* operator-&gt;() const &#123; return  px;&#125;</span><br><span class="line"></span><br><span class="line">  shared_ptr(T* p) : px(p) &#123;&#125;</span><br><span class="line">private:</span><br><span class="line">  T* px;</span><br><span class="line">  long* pn;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">shared_ptr&lt;Foo&gt; sp(new Foo);</span><br><span class="line">Foo f(*sp);  //调用*操作符</span><br><span class="line">sp-&gt;method(); //调用-&gt;操作符，这里编译器自动其转化为px-&gt;method()。-&gt;符号的特别在于它会对其作用的结果继续进行操作，这是C++的语言特性。</span><br></pre></td></tr></table></figure>

<p>迭代器也是一种智能指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line">struct __list_node&#123;</span><br><span class="line">    void* prev;</span><br><span class="line">    void* next;</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T, class Ref, class Ptr&gt;</span><br><span class="line">struct __list_iterator&#123;</span><br><span class="line">    typedef __list_iterator&lt;T, Ref, Ptr&gt; self;</span><br><span class="line">    typedef Ptr pointer;</span><br><span class="line">    typedef Ref reference;</span><br><span class="line">    typedef __list_node&lt;T&gt;* link_type;</span><br><span class="line">    link_type node;</span><br><span class="line"></span><br><span class="line">    bool operator == (const self&amp; x) const &#123;return node == x.node;&#125;</span><br><span class="line">    bool operator != (const self&amp; x) const &#123;return node != x.node;&#125;</span><br><span class="line">    reference operator*() const &#123;return (*node&#125;.data;&#125;</span><br><span class="line">    pointer operator-&gt; const &#123;return &amp;(operator*());&#125;</span><br><span class="line">    self&amp; operator++() &#123;node = (link_type)((*node).next);return *this;&#125;  //前缀++ </span><br><span class="line">    self operator++(int) &#123;self tmp = *this; ++*this; return tmp;&#125;       //后缀++,调用实例i的后缀++时会自动转换为 i.operator++(0)。</span><br><span class="line">    self&amp; operator--() &#123;node = (link_type)((*node).prev;return *this;&#125;</span><br><span class="line">    self operator--(int) &#123;self tmp = *this; --*this; return tmp;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Function-like class</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//由于下面的类都重载了operator()()函数（括号运算符），因此都是函数式对象</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">struct identity&#123;</span><br><span class="line">  const T&amp;</span><br><span class="line">  operator()(const T&amp; x) const &#123;return x;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class Pair&gt;</span><br><span class="line">struct select1st&#123;</span><br><span class="line">  const typename Pair::first_type&amp;</span><br><span class="line">  operator()(const Pair&amp; x) const &#123; return x.first; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class Pair&gt;</span><br><span class="line">struct select2nd&#123;</span><br><span class="line">  const typename Pair::second&amp;</span><br><span class="line">  operator()(const Pair&amp; x) const &#123; return x.second; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p>####<a href="#3">Template模板</a><br>三种模板：<br><strong>1. Class templat</strong><br><strong>2.Function template</strong><br>编译器会对function template进行实参推导（argument deduction)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line">inline const T&amp; min(const T&amp;a, const T&amp; b)&#123;</span><br><span class="line">    return b &lt; a ? b : a; //若找不到bool T::operator &lt; (const T&amp;) const 会出现错误。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stone r1(2,3),r2(3,3), r3;</span><br><span class="line">r3 = min(r1,r2);//这里的T被推导为stone</span><br><span class="line">```   </span><br><span class="line">**3.Member template**</span><br></pre></td></tr></table></figure>

<p>//例一 pair<br>template &lt;class T1, class T2&gt;<br>struct pair{<br>    typedef T1 first_type;<br>    typedef T2 second_type;</p>
<pre><code>T1 first;
T2 second;

pair():first(T1()), second(T2()) {}
pair(const T1&amp; a, const T2&amp; b):first(a), second(b) {}

template &lt;class U1, class U2&gt;
pair(const pair&lt;U1, U2&gt;&amp; p): first(p.first), second(p.second) {}</code></pre><p>};</p>
<p>class Base1{};<br>class Derived1: public Base1{};</p>
<p>class Base2{};<br>class Derived2: public Base2{};</p>
<p>pair&lt;Derived1, Derived2&gt; p;</p>
<p>pair&lt;Base1, Base2&gt; p2(p); // 调用了成员模板</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>//例二 shared_ptr<br>template<typename _tp><br>class shared_ptr: public <strong>shared_ptr&lt;_Tp&gt;{<br>…<br>    template<typename _tp1><br>    explicit shared_ptr(_Tp1* __p)<br>      :</typename></strong>shared_ptr&lt;_Tp&gt;(__p){}<br>…<br>};</typename></p>
<p>Base1* ptr = new Derived1; //up-cast</p>
<p>shared_ptr<base1> sptr(new Derived1); // 模拟 up-cast</base1></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">------------------</span><br><span class="line"></span><br><span class="line">####[Specialization特化](#4)</span><br><span class="line"></span><br><span class="line">关于特化的理解和讨论，下面内容转载自：http://www.blogjava.net/bacoo/archive/2009/06/22/283480.html</span><br><span class="line"></span><br><span class="line">&gt;  对模板特化的理解：</span><br><span class="line">特化整体上分为全特化和偏特化，这一点大家都没有什么置疑，但是细分它们各包括哪几种状态就很难界定了，而且很多权威的书上都不一致，管它呢，反正我们能会用各种特化就可以了。</span><br><span class="line">下面就谈谈我个人对特化的划分和定义：</span><br><span class="line">所谓特化，就是将泛型的东东搞得具体化一些，从字面上来解释，就是为已有的模板参数进行一些使其特殊化的指定，使得以前不受任何约束的模板参数，或受到特定的修饰（例如const或者摇身一变成为了指针之类的东东，甚至是经过别的模板类包装之后的模板类型）或完全被指定了下来。&lt;br&gt;  </span><br><span class="line">这是网上某个人的一些看法：  </span><br><span class="line">模板有两种特化，全特化和偏特化（局部特化）。  </span><br><span class="line">模板函数只能全特化，没有偏特化（以后可能有）。  </span><br><span class="line">模板类是可以全特化和偏特化的。  </span><br><span class="line">全特化，就是模板中模板参数全被指定为确定的类型。  </span><br><span class="line">全特化也就是定义了一个全新的类型，全特化的类中的函数可以与模板类不一样。  </span><br><span class="line">偏特化，就是模板中的模板参数没有被全部确定，需要编译器在编译时进行确定。  </span><br><span class="line">在类型上加上const、&amp;、*（ cosnt int、int&amp;、int*、等等）并没有产生新的类型。只是类型被修饰了。模板在编译时，可以得到这些修饰信息。  </span><br><span class="line">&lt;br&gt;我个人也比较赞同这位仁兄的划分，全特化的标志就是产生出完全确定的东西，而不是还需要在编译期间去搜寻适合的特化实现，貌似在我的这种理解下，全特化的东西不论是类还是函数都有这样的特点，template &lt;&gt;然后是完全和模板类型没有一点关系的类实现或者函数定义，如果你要说，都完全确定下来了，那还搞什么模板呀，直接定义不就完事了？但是很多时候，我们既需要一个模板能应对各种情形，又需要它对于某个特定的类型（比如bool）有着特别的处理，这中情形下就是需要的了。&lt;br&gt;</span><br><span class="line">既然刚才提到了全特化的标志，那么再说说其他一些共性的东西：</span><br><span class="line">一个特化的模板类的标志：在定义类实现时加上了&lt;&gt;，比如class A&lt;int, T&gt;；而在定义一个模板类的时候，class A后面是没有&lt;&gt;的</span><br><span class="line">全特化的标志：template &lt;&gt;然后是完全和模板类型没有一点关系的类实现或者函数定义</span><br><span class="line">偏特化的标志：template &lt;typename T.....&gt;，就是说还剩下点东西，不像全特化&lt;&gt;整得那么彻底</span><br><span class="line"></span><br><span class="line">**模板偏特化有两种：**  </span><br><span class="line">1）个数的偏</span><br></pre></td></tr></table></figure>

<p>template&lt;typename T, typename Alloc=……&gt;<br>class vector{ …… }</p>
<p>…</p>
<p>template<typename alloc="......"><br>class vector&lt;bool, Alloc&gt; { // 第一个模板参数被绑定<br>…</typename></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2）范围的偏</span><br></pre></td></tr></table></figure>

<p>template<typename t><br>class C { …… };</typename></p>
<p>template <typename u><br>class C&lt;U*&gt; { …… };</typename></p>
<p>C<string> obj1;<br>C&lt;string*&gt; obj2; //特化的C </string></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**template template parameter模板模板参数**</span><br></pre></td></tr></table></figure>

<p>template&lt;typename T,<br>         template <typename t><br>             class Container<br>        &gt;<br>class XCls{<br>private:<br>    Container<t> c;<br>public:<br>    …<br>};</t></typename></p>
<p>template<typename t><br>using Lst = list&lt;T, allocator<t> &gt;;</t></typename></p>
<p>XCls&lt;string, list&gt; mylst1;  // 错误, 因为没有指定allocator，而是使用默认的。<br>XCls&lt;string, Lst&gt;  mylst2;  // 正确</p>
<p>// 注意，下面的例子不是模板模板参数<br>template&lt;class T, class Sequence = deque<t> &gt;<br>class stack {<br>    friend bool operator== &lt;&gt; (const stack&amp;,const stack&amp;);<br>    friend bool operator&lt;  &lt;&gt; (const stack&amp;,const stack&amp;);<br>protectd:<br>    Sequence c; //底层容器<br>…<br>};</t></p>
<p>stack&lt;int, list<int> s2;//这里的第二个模板参数是写成固定的，是绑定了某个类的，并不是一个“模板”。</int></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------------------</span><br><span class="line"></span><br><span class="line">####[关于C++11的三个新特性](#5)  </span><br><span class="line"> </span><br><span class="line">一，variadic template可变模板参数。</span><br></pre></td></tr></table></figure>

<p>// “…” 是一个pack(包)<br>template&lt;typename T, typename… Types&gt; // template parameters pack(模板参数包)<br>void print(const T&amp; firstArg, const Types&amp;… args){ // function parameter types pack(函数参数类型包)<br>    cout&lt;&lt;firstArg&lt;&lt;endl;<br>    print(args…); // function parameters pack(函数参数包)<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可以使用sizeof...(args)返回参数的数量。</span><br><span class="line"></span><br><span class="line">二，auto 关键字，一个语法糖，方便开发者编写复杂的代码。</span><br></pre></td></tr></table></figure>

<p>list<string>::iterator ite1;<br>ite1 = find(c.begin(),c.end(),target);</string></p>
<p>auto ite2= find(c.begin(),c.end(),target); //省略了ite1复杂的声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">三，ranged-base for</span><br></pre></td></tr></table></figure>

<p>for(int i : {2,3,5,7,9} ){ // 大括号的用法是列表初始化，也是c++11新的特性<br>    cout &lt;&lt; i &lt;&lt; endl;<br>}</p>
<p>vector<double> vec;<br>…<br>for (auto  elem : vec) { … } // pass by value<br>for (auto&amp; elem : vec) { … } // pass by reference</double></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">--------------</span><br><span class="line">####[再谈reference](#6)</span><br><span class="line">关于reference要注意的点：  </span><br><span class="line"></span><br><span class="line">一，object和其reference的大小相同，地址也相同（都是编译器造成的假象，reference其实是一个指针）。因此，在下面的变量定义中，有1）`sizeof(r) == sizeof(x)`，2）`&amp;x == &amp;&amp;r;`</span><br></pre></td></tr></table></figure>

<p>int  x = 0;<br>int&amp; r = x;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二，reference是一种漂亮的pointer。它通常不用于声明变量，而用于==参数类型(parameters type)==和==返回类型(return type)==的描述。在参数类型中，尽量不要使用传指针的方式来调用函数。要尽量使用传值或者传应用的方式来使用函数。但是要注意下面的这种情况：</span><br></pre></td></tr></table></figure>

<p>double func1(const double&amp; num) {…}<br>double funct(const double  num) {…}</p>
<pre><code>以上两个函数被视为“same signature”，会导致ambiguity。但是函数后面的const也是函数签名的一部分，因此可以用来标识不同的函数。  

关于函数签名，下面是**《C++ Templates》**中的解释：
&gt; 
只要具有不同的签名，两个函数就可以在同一个程序中同时存在  
对于函数签名的定义如下：  
1.非受限函数的名称或产生自模板的这类名称。  
2.函数名称所属的类作用域或者名字空间作用域；如果函数名称是具有内部链接的，还包括该名称的声明所在的翻译单元。  
3.函数的const，volatile或者const volatile限定符（前提是它是一个具有这类限定符的函数）  
4.函数的参数的类型和个数，如果这个函数是产生自函数模板的，那么指的是模板参数被替换之前的类型  
5.如果这个函数产生自模板，那么包括它的返回值  
6.如果这个函数产生自模板，那么包括模板参数和模板实参  

</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/23/shang-ke-bi-ji-for-geekband-cmian-xiang-dui-xiang-gao-ji-bian-cheng-shang-part-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Tang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IndigoAxe">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/23/shang-ke-bi-ji-for-geekband-cmian-xiang-dui-xiang-gao-ji-bian-cheng-shang-part-3/" itemprop="url">[上课笔记 for GeekBand] C++面向对象高级编程（上） part.3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-23T07:45:26+08:00">
                2018-05-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>第三周的主要内容有：</p>
<p><a href="#1">1. 组合与继承</a><br><a href="#2">2. 虚函数与多态</a><br><a href="#3">3. 委托相关设计</a>  </p>
<ol start="4">
<li>复合和继承关系下的构造和析构</li>
</ol>
<hr>
<h4 id="组合与继承"><a href="#组合与继承" class="headerlink" title="组合与继承"></a><a href="#1">组合与继承</a></h4><p>类与类之间主要有三种关系，在程序中，这三种关系能解决大部分问题：   </p>
<ul>
<li>Inheritance（继承）</li>
<li>Composition（复合）</li>
<li>Delegation（委托）</li>
</ul>
<p>==<strong>Inheritance（继承）</strong>==<br>表示了一种is-a的关系，即子类继承了父类的部分：<br><img src="/content/images/2018/05/interitance1.jpg" alt="inheritance1"><br>子类的遵循构造由内到外（从父类到子类），析构由外到内的规则。<br>注意：父类的析构函数必须是虚函数，否则会出现undifined behavior。  </p>
<p>==<strong>Composition（复合）</strong>==<br>表示了一种has-a的关系，例如一间屋子里面有(has)许多房间，有屋子，就会有房间。而如果屋子被拆了(析构)，房间也会被“析构”。我们可以通过下图来直观地了解compositon。注意其中标红文字的部分，它们表示了编译器为派生类自动添加的代码。<br><img src="/content/images/2018/05/composition1.jpg" alt="composition"><br>利用composition来实现adapter设计模式:<br><img src="/content/images/2018/05/adapter.jpg" alt="adapter"></p>
<p>==<strong>Delegation（委托）</strong>==<br>Delegation实际上是composition by reference。<br>这种实现方式又叫pimpl(pointer to implementation) 或是 handle/body。<br>Delegation是一种编译防火墙，如果把handle看作客户端，那么操作有改动的时候只需改动body，而不需要改动客户端。即客户端不需要重新编译，而只需要重新编译body部分。换而言之，delegation将某个类的成员函数交给另外一个类去实现，从客观上减少了该类的代码实现。例子如下:<br><img src="/content/images/2018/05/delegation.jpg" alt="delegation"></p>
<hr>
<h4 id="虚函数与多态"><a href="#虚函数与多态" class="headerlink" title="虚函数与多态"></a><a href="#2">虚函数与多态</a></h4><p>继承的强大，大多是靠虚函数来实现的。子类继承父类的成员变量会占用同样的内存空间，而对于父类的成员函数则继承的是调用权。函数的继承，有下面三种：<br><img src="/content/images/2018/05/virtualmethod1.jpg" alt="virtualmethod1"></p>
<ul>
<li>override = 重新定义</li>
<li>如果把虚函数写成空函数，它跟纯虚函数还是有区别的。区别就在于子类必须override纯虚函数，而非纯虚函数则不用</li>
<li>关于虚函数的使用，老师介绍了<strong>template method（模板方法）</strong>模式这一最常用的使用案例。  </li>
<li><em>模板方法*</em>：准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。模版方法模式需要开发抽象类和具体子类的设计师之间的协作。一个设计师负责给出一个算法的轮廓和骨架，另一些设计师则负责给出这个算法的各个逻辑步骤。代表这些具体逻辑步骤的方法称做基本方法（primitive method）；而将这些基本法方法总汇起来的方法叫做模版方法（template method），这个设计模式的名字就是从此而来。  </li>
</ul>
<hr>
<h4 id="委托相关设计"><a href="#委托相关设计" class="headerlink" title="委托相关设计"></a><a href="#3">委托相关设计</a></h4><br>
==**Observer(观察者)设计模式**==  
观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。
观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。  
Observer模式通常可以用delegation+inheritance的方式去实现。话不多说，上示例代码：

<p>Source:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Subject&#123;</span><br><span class="line">    int m_value;</span><br><span class="line">    vector&lt;Observer*&gt; m_views;</span><br><span class="line">public:</span><br><span class="line">    void attach(Observer* obs)&#123;</span><br><span class="line">        m_views.push_back(obs);</span><br><span class="line">    &#125;</span><br><span class="line">    void set_val(int value)&#123;</span><br><span class="line">        m_value = value;</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">    void notify()&#123;</span><br><span class="line">        for(int i=0;i&lt;m_views.size();++i)</span><br><span class="line">            m_views[i]-&gt;update(this,m_value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Listener:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Observer&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void update(Subject* sub, int value) = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>==<strong>Composite(组合)设计模式</strong>==<br>组合模式将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。有时候又叫做部分-整体模式，它使我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素,从而使得客户程序与复杂元素的内部结构解耦。<br>　　组合模式让你可以优化处理递归或分级数据结构。有许多关于分级数据结构的例子，使得组合模式非常有用武之地。下面是课程中的例子:<br><img src="/content/images/2018/05/composite1.jpg" alt="composite1"></p>
<p>==<strong>Prototype(原型)设计模式</strong>==<br>以下内容转自：<a href="http://www.jellythink.com/archives/105" target="_blank" rel="noopener">http://www.jellythink.com/archives/105</a><br>在GOF的《设计模式：可复用面向对象软件的基础》中是这样说的：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。这这个定义中，最重要的一个词是“拷贝”，也就是口头上的复制，而这个拷贝，也就是原型模式的精髓所在。<br>原型模式的UML表示：<br><img src="/content/images/2018/05/PrototypePattern.png" alt="prototype"></p>
<p>与其它创建型模式的比较</p>
<p>工厂方法模式、抽象工厂模式、建造者模式和原型模式都是创建型模式。工厂方法模式适用于生产较复杂，一个工厂生产单一的一种产品的时候；抽象工厂模式适用于一个工厂生产多个相互依赖的产品；建造者模式着重于复杂对象的一步一步创建，组装产品的过程，并在创建的过程中，可以控制每一个简单对象的创建；原型模式则更强调的是从自身复制自己，创建要给和自己一模一样的对象。</p>
<pre><code>注：使用原型模式复制对象不会调用类的构造方法。因为对象的复制是通过调用Object类的clone方法来完成的，它直接在内存中复制数据，因此不会调用到类的构造方法。不但构造方法中的代码不会执行，甚至连访问权限都对原型模式无效。还记得单例模式吗？单例模式中，只要将构造方法的访问权限设置为private型，就可以实现单例。但是clone方法直接无视构造方法的权限，所以，单例模式与原型模式是冲突的，在使用时要特别注意。</code></pre><p>模式的应用场景：<br>       使用原型模式创建对象比直接new一个对象在性能上要好的多，因为Object类的clone方法是一个本地方法，它直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明显。</p>
<p><strong>总结：</strong>侯老师本周主要介绍了类的三种重要的关系（组合，委托，继承）。然后通过这三种关系，跟我们分析了面向对象编程中的一些问题的解决方案以及其中的原理。在这期间还讨论了如何通过这三种关系的组合，来实现几种常见的设计模式：Adapter, Template Method, Observer, Composite和Prototype。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/19/copyctor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Tang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IndigoAxe">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/19/copyctor/" itemprop="url">[上课笔记 for GeekBand] C++面向对象高级编程（上） part.2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-19T03:12:00+08:00">
                2018-05-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>第二周课程的主要内容是：<br><br><a href="#1">1. 三大函数：拷贝构造，拷贝赋值，析构</a><br><br><a href="#2">2. 堆，栈与内存管理</a><br><br><a href="#3">3. 复习string类的实现过程</a><br><br><a href="#4">4. 扩展补充：类模板，函数模板，及其他</a></p>
<hr>
<h4 id="1">==三大函数：拷贝构造，拷贝赋值，析构==</h4>
关于这三大函数的介绍，下面内容来自《高质量C++/C编程指南》-第9章-类的构造函数、析构函数与赋值函数的介绍和分析：
>构造函数、析构函数与赋值函数是每个类最基本的函数。它们太普通以致让人容易麻痹大意，其实这些貌似简单的函数就象没有顶盖的下水道那样危险。 每个类只有一个析构函数和一个赋值函数，但可以有多个构造函数（包含一个拷贝构造函数，其它的称为普通构造函数）。对于任意一个类A，如果不想编写上述函数，C++编译器将自动为A产生四个缺省的函数，如
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A(void); // 缺省的无参数构造函数</span><br><span class="line">A(const A &amp;a); // 缺省的拷贝构造函数</span><br><span class="line">~A(void); // 缺省的析构函数</span><br><span class="line">A &amp; operate =(const A &amp;a); // 缺省的赋值函数</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这不禁让人疑惑，既然能自动生成函数，为什么还要程序员编写？<br>原因如下：<br><br>（1）如果使用“缺省的无参数构造函数”和“缺省的析构函数”，等于放弃了自主“初始化”和“清除”的机会，C++发明人Stroustrup的好心好意白费了。<br><br>（2）“缺省的拷贝构造函数”和“缺省的赋值函数”==均采用“位拷贝”而非“值拷贝”的方式来实现，倘若类中含有指针变量，这两个函数注定将出错。==<br><br>对于那些没有吃够苦头的C++程序员，如果他说编写构造函数、析构函数与赋值函数很容易，可以不用动脑筋，表明他的认识还比较肤浅，水平有待于提高。<br>本章以类String的设计与实现为例，深入阐述被很多教科书忽视了的道理。String的结构如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class String</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">String(const char *str = NULL); // 普通构造函数</span><br><span class="line">String(const String &amp;other); // 拷贝构造函数</span><br><span class="line">~ String(void); // 析构函数</span><br><span class="line">String &amp; operate =(const String &amp;other); // 赋值函数</span><br><span class="line">private:</span><br><span class="line">char *m_data; // 用于保存字符串</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>==<strong>下面是侯老师讲课的时候强调的一些重要的点</strong>==</p>
<ul>
<li><p><strong>如果对象是带指针成员变量的，一定要自定义这三大函数。如果使用默认拷贝函数，会导致浅拷贝出现，从而导致内存泄漏。因为被赋值的指针原来所指向的内存没有被释放，而且再也没有指针指向它。如下图：</strong><br><img src="/content/images/2018/05/QQ--20180519154500-2.png" alt="copyctor"></p>
</li>
<li><p><strong>尽量使用指针来定义类中的成员变量，而不是直接存储变量的值。</strong>（如上面代码中的*m_date）</p>
</li>
<li><p><strong>函数传入一个指针时，记住要先判断它是否是空指针。而传引用则不用。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">inline</span><br><span class="line">String::String(const char* cstr)</span><br><span class="line">&#123;  </span><br><span class="line">   // 因为传入的是指针，所以需要检测它是否为空指针。</span><br><span class="line">   if (cstr) &#123;</span><br><span class="line">      m_data = new char[strlen(cstr)+1];</span><br><span class="line">      strcpy(m_data, cstr);</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;   </span><br><span class="line">      m_data = new char[1];</span><br><span class="line">      *m_data = &apos;\0&apos;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>对于指向对象的指针，离开其作用域前，一定要注意用delete释放该指针。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    string s1(&quot;hello&quot;);</span><br><span class="line">    string s2(&quot;world&quot;);</span><br><span class="line"></span><br><span class="line">    string *p = new string(&quot;geekband&quot;);</span><br><span class="line">    delete p;//离开作用域前要释放指针</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>拷贝构造函数和拷贝赋值函数的区别，以及拷贝赋值函数需要注意的地方：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">inline</span><br><span class="line">String&amp; String::operator=(const String&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">   // 检测是否是自我赋值， 如果不检测自我赋值，会导致strcpy出现未定义的行为（原来的指针已经被删除）</span><br><span class="line">   if (this == &amp;str)</span><br><span class="line">      return *this;</span><br><span class="line">   // 需要先释放原来已分配的内存，然后再重新分配一块新的</span><br><span class="line">   delete[] m_data;</span><br><span class="line">   m_data = new char[ strlen(str.m_data) + 1 ];</span><br><span class="line">   strcpy(m_data, str.m_data);</span><br><span class="line">   return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline</span><br><span class="line">String::String(const String&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">   m_data = new char[ strlen(str.m_data) + 1 ];</span><br><span class="line">   strcpy(m_data, str.m_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h4 id="2">==堆，栈与内存管理==</h4>
来源：http://www.cnblogs.com/heyonggang/p/3250220.html

<ul>
<li><strong>c++ 的内存分配</strong></li>
</ul>
<p>　　在一些资料中是这样定义C++内存分配的，可编程内存在基本上分为这样的几大部分：静态存储区、堆区和栈区。他们的功能不同，对他们使用方式也就不同。</p>
<p>　　a)静态存储区：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据、全局数据和常量。</p>
<p>　　b)栈区：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p>
<p>　　c)堆区：亦称动态内存分配。程序在运行的时候用malloc或new申请任意大小的内存，程序员自己负责在适当的时候用free或delete释放内存。动态内存的生存期可以由我们决定，如果我们不释放内存，程序将在最后才释放掉动态内存。 <strong>但是，良好的编程习惯是：如果某动态内存不再使用，需要将其释放掉，否则，我们认为发生了内存泄漏现象。</strong></p>
<p>　　全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的 C 语言中，全局变量又分为初始化的和未初始化的（初始化的全局变量和静态变量在一块区域，未初始化的全局变量与静态变量在相邻的另一块区域，同时未被初始化的对象存储区可以通过 void* 来访问和操纵，程序结束后由系统自行释放），在 C++ 里面没有这个区分了，他们共同占用同一块内存区。</p>
<p>　　常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改（当然，你要通过非正当手段也可以修改，而且方法很多）<br><img src="/content/images/2018/05/7651004135.jpg" alt="classic_memory"></p>
<ul>
<li><strong>堆与栈区别</strong></li>
</ul>
<p>我们先通过例子1来直观的说明下栈与堆内存的区别，然后在细致分析例子2中的情况。</p>
<p>　　例子1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> void fn()&#123; </span><br><span class="line">     int* p = new int[5]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　看到new，首先应该想到，我们分配了一块堆内存，那么指针p呢? 它分配的是一块栈内存，所以这句话的意思就是:在栈内存中存放了一个指向一块堆内存的指针p。程序会先确定在堆中分配内存的大小，然后调用 operator new分配内存，然后返回这块内存的首地址，放入栈中。</p>
<p>　　注意：这里为了简单并没有释放内存，那么该怎么去释放呢? 是deletep么? NO，错了，应该是delete [ ] p，这是告诉编译器:删除的是一个数组。</p>
<p>例子2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int a = 0; //全局初始化区</span><br><span class="line">char *p1; //全局未初始化区</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int b; //栈 </span><br><span class="line">   char s[] = &quot;abc&quot;; //栈 </span><br><span class="line">   char *p2; //栈 </span><br><span class="line">   char *p3 = &quot;123456&quot;; // 123456\0在常量区，p3在栈上。 </span><br><span class="line">   static int c =0; //全局(静态)初始化区 </span><br><span class="line">   p1 = (char *)malloc(10); </span><br><span class="line">   p2 = (char *)malloc(20); 12: //分配得来得10和20字节的区域就在堆区。 </span><br><span class="line">   strcpy(p1, &quot;123456&quot;); //123456\0放在常量区，编译器可能会将它与p3所指向的&quot;123456&quot;优化成一个地方。 </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>例子3：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">char* f1() </span><br><span class="line">&#123; </span><br><span class="line">    char* p = NULL; </span><br><span class="line">    char a; </span><br><span class="line">    p = &amp;a;</span><br><span class="line">    return p; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">char* f2() </span><br><span class="line">&#123; </span><br><span class="line">    char* p = NULL;</span><br><span class="line">    p =(char*) new char[4]; </span><br><span class="line">    return p; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这两个函数都是将某个存储空间的地址返回，二者有何区别呢?f1()函数虽然返回的是一个存储空间，但是此空间为临时空间。也就是说，此空间只 有短暂的生命周期，它的生命周期在函数f1()调用结束时，也就失去了它的生命价值，即：此空间被释放掉。所以，当调用f1()函数时，如果程序中有下面的语句：</p>
<p>　　<code>char* p ; p = f1(); *p = ‘a’;</code></p>
<p>　　此时，编译并不会报告错误，但是在程序运行时，会发生异常错误。因为，你对不应该操作的内存(即，已经释放掉的存储空间)进行了操作。但是，相 比之下，f2()函数不会有任何问题。因为，new这个命令是在堆中申请存储空间，一旦申请成功，除非你将其delete或者程序终结，这块内存将一直存 在。也可以这样理解，堆内存是共享单元，能够被多个函数共同访问。如果你需要有多个数据返回却苦无办法，堆内存将是一个很好的选择。但是一定要避免下面的 事情发生：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　void f()&#123; </span><br><span class="line">    … </span><br><span class="line">    char * p; </span><br><span class="line">    p = (char*)new char[100]; </span><br><span class="line">    … </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这个程序做了一件很无意义并且会带来很大危害的事情。因为，虽然申请了堆内存，p保存了堆内存的首地址。但是，此变量是临时变量，当函数调用结 束时p变量消失。也就是说，再也没有变量存储这块堆内存的首地址，我们将永远无法再使用那块堆内存了。但是，这块堆内存却一直标识被你所使用(因为没有到 程序结束，你也没有将其delete，所以这块堆内存一直被标识拥有者是当前您的程序)，进而其他进程或程序无法使用。我们将这种不道德的“流氓行为” (我们不用，却也不让别人使用)称为内存泄漏(memory leak)。</p>
<p>　　综合以上两个例子，我们可以总结一下堆与栈到底有哪些区别:</p>
<p>　　<strong>(1)管理方式不同</strong></p>
<p>　　对于栈来讲，是由编译器自动管理，无需我们手工控制;对于堆来说，释放工作由程序员控制，容易产生memory leak。</p>
<p>　　<strong>(2)空间大小不同</strong></p>
<p>　　空间大小:一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6.0下面默认的栈空间大小是1M,可以修改这个值。</p>
<p>　　<strong>(3)能否产生碎片不同</strong></p>
<p>　　对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题， 因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出。</p>
<p>　　<strong>(4)生长方向不同</strong></p>
<p>　　对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向;对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。(详见第一部分的内存分配图)</p>
<p>　　<strong>(5)分配方式不同</strong></p>
<p>　　堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</p>
<p>　　<strong>(6)分配效率不同</strong></p>
<p>　　栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比 较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法(具体的算法可以参考数据结构/操作系统)在堆 内存中搜索可用的足够大小的空间，如果没有足够大小的空间(可能是由于内存碎片太多)，就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分 到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</p>
<p>　　<strong>==总结：==</strong></p>
<p>　　堆和栈相比，由于大量new/delete的使用，容易造成大量的内存碎片;由于没有专门的系统支持，效率很低;由于可能引发用户态和核心态的 切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP和局部变 量都采用栈的方式存放。所以，推荐大家尽量用栈，而不是用堆。</p>
<p>　　虽然栈有如此众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。</p>
<p>　　无论是堆还是栈，都要防止越界现象的发生(除非你是故意使其越界)，因为越界的结果要么是程序崩溃，要么是摧毁程序的堆、栈结构，产生以想不到 的结果,就算是在你的程序运行过程中，没有发生上面的问题，你还是要小心，说不定什么时候就崩掉，那时候debug可是相当困难。</p>
<ul>
<li><p><strong>其他需要注意的点</strong></p>
<ol>
<li>new操作符是先分配memory,再调用构造函数。而delete操作符则是先调用析构函数再释放memory。注意下面两张图中编译器对new/delete操作符的转化。<br><img src="/content/images/2018/05/new.jpg" alt="new"><br><img src="/content/images/2018/05/delete.jpg" alt="delete"></li>
</ol>
<p>2.array new一定要搭配array delete(delete [])。delete[]可以释放array所占用的内存，并且调用所有元素的析构函数。而delete只会调用第一个元素的析构函数，可能会造成其他元素的内存泄漏。</p>
<p>3.静态函数只能处理静态数据，因为它没有this指针的传入。<br><img src="/content/images/2018/05/static-1.jpg" alt="static"></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/18/shang-ke-bi-ji-cmian-xiang-dui-xiang-gao-ji-bian-cheng-shang-part-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Tang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IndigoAxe">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/18/shang-ke-bi-ji-cmian-xiang-dui-xiang-gao-ji-bian-cheng-shang-part-1/" itemprop="url">[上课笔记 for GeekBand] C++面向对象高级编程（上）  part.1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-18T06:37:20+08:00">
                2018-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本周的课程内容为：<br></p>
<ol>
<li>C++编程简介 </li>
<li>头文件与类的声明 </li>
<li>构造函数 </li>
<li>参数传递与返回值</li>
<li>操作符重载与临时对象</li>
<li>复习complex类的实现过程</li>
</ol>
<p>下面是这一周的课程笔记。因为有一些课程内容已经比较熟悉，所以只会挑一些需要强调的或者不太熟悉的内容来做作记录。</p>
<hr>
<h4 id="C-的学习"><a href="#C-的学习" class="headerlink" title="==C++的学习=="></a>==C++的学习==</h4><ul>
<li><p><strong>两大部分，首先学习Object Based(基于对象)，然后是 Object Oriented(面向对象)。</strong></p>
<p> 关于这两种编写对象的方式有一个很简单的区分：<br><br> Object Based - Class without pointer members<br><br> Object Orient - Class with pointer members<br></p>
<p>关于这个内容，在《深度探索C++对象模型》第一章有进一步的讨论：</p>
<blockquote>
<p>  Object-oriented支持Polymorphism,而Object-based不支持Polymorphism.主要的区别就在于此。支持多态的代价是额外的间接性–不论是在“内存的获得”或是在“类型的决断”上。<br>C++通过class的pointers和references来支持多态，这种程序设计风格就叫面向对象。<br>C++也支持具体的ADT程序风格，被称为基于对象，它只支持封装，不支持类型的扩充。<br>一个Object-based设计可能比一个对等的Object-oriented设计速度更快而且空间更紧凑。速度快是因为所有的函数引发操作都在编译时期解析完成，不需要设置virtual机制；空间紧凑则是因为每一个class object不需要负担传统上为了支持virtual机制而需要的额外负担。不过，Object-based设计比较没有弹性。</p>
</blockquote>
</li>
</ul>
<p>注：ADT- Abstract Data Type 抽象数据类型,是一个实现包括储存数据元素的存储结构以及实现基本操作的算法。</p>
<ul>
<li><strong>学习一门语言主要学的是这门语言的两个部分：语言和标准库。</strong></li>
</ul>
<hr>
<p>#####==构造函数==</p>
<ul>
<li><p><strong>构造函数和析构函数可以被显式地调用，但是不建议这么使用，因为有可能会导致内存泄漏。</strong></p>
<pre><code>这是因为，在已创建的对象上显式地调用构造函数时, 其所指向的动态内存将会被更新。然而对象生命周期结束时析构函数所释放掉的是最后一次分配的动态内存, 也就是说之前隐式构造函数所分配的那块内存被泄漏了。而显式调用析构函数，则会导致隐式调用析构函数时重复释放同一块内存。</code></pre></li>
<li><p><strong>将constructor设为private,可以用于实现singleton。</strong></p>
<pre><code>//常见的singleton类的声明
class Singleton
  {
     private:
       static Singleton* pInstance;//静态成员，保存对象的唯一实例
       Singleton();//私有化构造函数，使其无法在类外实例化
     public:
       static Singleton* Instance();
       //void Destroy();
       static void Destroy();
   };</code></pre></li>
<li><p><strong>可以声明为常量成员函数的，一定要加const。</strong></p>
<pre><code>注: 用mutable关键字修饰类成员变量，可以突破const的限制，在常量成员函数中修改成员变量。</code></pre></li>
</ul>
<hr>
<p>####==参数传递与返回值==</p>
<ul>
<li><p><strong>使用函数时，尽量传递引用(by referrence)参数和返回引用值。这样可以提高程序运行的效率，是C++的优势之一。</strong></p>
<pre><code>注意，不要返回局部对象的引用或指针。可以用return typename()的方式利用临时未命名的变量返回一个值。</code></pre></li>
<li><p><strong>相同class的各个object互为友元。</strong></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/11/02/plsql-zhong-de-you-biao-cursor-part2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Tang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IndigoAxe">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/11/02/plsql-zhong-de-you-biao-cursor-part2/" itemprop="url">PL/SQL 中的游标(CURSOR) - PART2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-11-02T07:45:56+08:00">
                2015-11-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#####4. 操纵游标数据</p>
<p>######4.1 LOOP循环<br>  <code>LOOP..END LOOP</code>是最基本的循环语句。使用它的关键在于要用<code>EXIT WHEN</code>来指定循环终止的条件。因此一个游标循环还需要包括<code>FETCH</code>、<code>EXIT WHEN</code>这两个子句。例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DECALARE </span><br><span class="line">  l_tab_row dba_tables%ROW_TYPE;</span><br><span class="line">  CURSOR l_tab_cur IS select * from dba_tables where rownum&lt;10;</span><br><span class="line">BEGIN</span><br><span class="line">  OPEN l_tab_cur;</span><br><span class="line">  LOOP</span><br><span class="line">    FETCH l_tab_cur INTO l_tab_row;</span><br><span class="line">    EXIT WHEN l_tab_cur%NOTFOUND;</span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(&apos;Table name: &apos;||l_tab_cur.table_name);</span><br><span class="line"> END LOOP;</span><br><span class="line"> CLOSE l_tab_cur;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>######4.2 WHILE循环<br>直接上例子吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line">  l_tab_row dba_tables%ROWTYPE;</span><br><span class="line">  CURSOR l_tab_cur IS select * from dba_tables where rownum&lt;10;</span><br><span class="line">BEGIN</span><br><span class="line">  OPEN l_tab_cur</span><br><span class="line">  FETCH l_tab_cur INTO l_tab_row;   --注意这里是先FETCH再进入循环</span><br><span class="line">  WHILE l_tab_cur$NOTFOUND LOOP</span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(&apos;Table name: &apos;||l_tab_cur.table_name);</span><br><span class="line">    FETCH l_tab_cur INTO l_tab_row;</span><br><span class="line">  END LOOP;</span><br><span class="line">  CLOSE l_tab_cur;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>######4.3 FOR循环<br>FOR循环与其他循环不同地方就是它不需要再使用<code>OPEN</code>、<code>FETCH</code>或<code>CLOSE</code>语句来操作游标。在这里，PL/SQL使用了一个隐式的变量来处理游标。因此使用FOR循环来操作游标会使代码变得非常的简洁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--使用FOR可以省略变量的定义</span><br><span class="line">BEGIN</span><br><span class="line">  FOR l_tab_row IN (select * from dba_tables where rownum&lt;10) LOOP</span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(&apos;Table name: &apos;||l_tab_row.table_name);</span><br><span class="line">  END LOOP;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>######4.4 修改游标数据<br>对从游标中获取的数据进行修改包含两个部分：<br><br>1） 在游标的声明中添加<code>FOR UPDATE [OF (column_list) [NOWAIT]]</code>语句。<br>如：<code>CURSOR l_tab_cur IS select * from dba_tables FOR UPDATE table_name,owner</code><br><br>该语句会将目标结果进行行级锁定，直到整个事务被提交为止。在声明中，OF(column_list)用于指定要锁定的列；NOWAIT表示当目标行已经被锁定时，<code>SELECT FOR UPDATE</code>语句将不等待解锁，而是直接返回。<br></p>
<p>2） 在<code>UPDATE</code>或<code>DELETE</code>语句中添加<code>WHERE CURRENT OF</code>语句。</p>
<p>来看看例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">-- 创建测试用表</span><br><span class="line">create table test (c1 number,c2 number,c3 number);</span><br><span class="line">BEGIN</span><br><span class="line">  FOR i in 1..10 LOOP</span><br><span class="line">    INSERT INTO test values(mod(i,3),i,null);</span><br><span class="line">  END LOOP;</span><br><span class="line">  COMMIT;</span><br><span class="line">END;</span><br><span class="line">/</span><br><span class="line">select * from test;</span><br><span class="line">-- 使用游标更新数据</span><br><span class="line">DECLARE</span><br><span class="line">  CURSOR l_test_cur (p_c1 test.c1%TYPE)</span><br><span class="line">  IS</span><br><span class="line">    SELECT * FROM test WHERE c1=p_c1</span><br><span class="line">    FOR UPDATE;</span><br><span class="line">BEGIN</span><br><span class="line">  FOR test_row IN l_test_cur(&apos;2&apos;) LOOP</span><br><span class="line">    IF test_row.c2&gt;5 THEN</span><br><span class="line">      UPDATE test SET c3=1</span><br><span class="line">      WHERE CURRENT OF l_test_cur;</span><br><span class="line">    END IF;</span><br><span class="line">  END LOOP;</span><br><span class="line">  COMMIT;</span><br><span class="line">END;</span><br><span class="line">/</span><br><span class="line">select * from test;</span><br></pre></td></tr></table></figure>

<p>最后test表中的内容应该是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from test;</span><br><span class="line"></span><br><span class="line">        C1         C2         C3</span><br><span class="line">---------- ---------- ----------</span><br><span class="line">         1          1</span><br><span class="line">         2          2</span><br><span class="line">         0          3</span><br><span class="line">         1          4</span><br><span class="line">         2          5</span><br><span class="line">         0          6</span><br><span class="line">         1          7</span><br><span class="line">         2          8          2</span><br><span class="line">         0          9</span><br><span class="line">         1         10</span><br><span class="line"></span><br><span class="line">10 rows selected.</span><br></pre></td></tr></table></figure>

<p><code>DELETE</code>的用法跟<code>UPDATE</code>差不多，就不举例了。</p>
<p>使用游标对数据进行修改，有两点需要注意：</p>
<ol>
<li>使用<code>WHERE CURRENT OF</code>子句检索的游标一定要在声明中有<code>FOR UPDATE</code>，并且游标要被打开且至少返回一行，否则会抛出异常。</li>
<li><code>COMMIT</code>语句必须要放在循环语句的后面，否则会导致游标更新或删除失败。</li>
</ol>
<p>#####5. 处理游标变量异常</p>
<h6 id="INVALID-CURSOR异常"><a href="#INVALID-CURSOR异常" class="headerlink" title="INVALID_CURSOR异常"></a><code>INVALID_CURSOR</code>异常</h6><p>如果要对一个未打开或者已关闭的游标变量进行<code>FETCH</code>,<code>CLOSE</code>或调用其属性的操作,<code>INVALID_CURSOR</code>异常将会被抛出。<br>解决的办法有两种：</p>
<ol>
<li>使用<code>OPEN FOR</code>将该游标打开</li>
<li>将一个已经打开过的相同类型游标变量赋给抛出异常的变量。</li>
</ol>
<p>下面来看看如何使用第二个方法处理<code>INVALID_CURSOR</code>变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">-- 创建测试用表</span><br><span class="line">create table test (c1 number,c2 number,c3 number);</span><br><span class="line">BEGIN</span><br><span class="line">  FOR i in 1..10 LOOP</span><br><span class="line">    INSERT INTO test values(mod(i,3),i,null);</span><br><span class="line">  END LOOP;</span><br><span class="line">  COMMIT;</span><br><span class="line">END;</span><br><span class="line">/</span><br><span class="line">select * from test;</span><br><span class="line">DECLARE</span><br><span class="line">  TYPE l_test_curtype IS REF CURSOR;</span><br><span class="line">  test_cur1 l_test_curtype;</span><br><span class="line">  test_cur2 l_test_curtype;</span><br><span class="line">  test_row test%ROWTYPE;</span><br><span class="line">BEGIN</span><br><span class="line">  OPEN test_cur1 FOR SELECT * FROM TEST;</span><br><span class="line">  FETCH test_cur1 INTO test_row;</span><br><span class="line">  DBMS_OUTPUT.PUT_LINE(&apos;c1: &apos;||test_row.c1);</span><br><span class="line">  FETCH test_cur2 INTO test_row;</span><br><span class="line">  DBMS_OUTPUT.PUT_LINE(&apos;c1: &apos;||test_row.c1);</span><br><span class="line">EXCEPTION</span><br><span class="line">  WHEN INVALID_CURSOR THEN</span><br><span class="line">    test_cur2:=test_cur1;</span><br><span class="line">    FETCH test_cur2 INTO test_row;</span><br><span class="line">    DBMS_OUTPUT.PUTLINE(&apos;c1: &apos;||test_row.c1);</span><br><span class="line">    OPEN test_cur2 FOR select * from test where c1&gt;5;</span><br><span class="line">    FETCH test_cur1 into test_row;</span><br><span class="line">    --由于test_cur1 与 test_cur2 共享相同的查询区域，因此结果相同</span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(&apos;c1: &apos;||test_row.c1);</span><br></pre></td></tr></table></figure>

<h6 id="ROWTYPE-MISMATCH异常"><a href="#ROWTYPE-MISMATCH异常" class="headerlink" title="ROWTYPE_MISMATCH异常"></a><code>ROWTYPE_MISMATCH</code>异常</h6><p>使用SYS_REFCURSOR来处理<code>ROWTYPE_MISMATCH</code>异常:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">create table test1 (c1 number,c2 number,c3 number);</span><br><span class="line">create table test2 (c1 number,c2 number);</span><br><span class="line">INSERT INTO test1 VALUES(1,2,3);</span><br><span class="line">INSERT INTO test2 VALUES(1,2);</span><br><span class="line">COMMIT;</span><br><span class="line">DECLARE </span><br><span class="line">  test_cur SYS_REFCURSOR;</span><br><span class="line">  test1_row test1%ROWTYPE;</span><br><span class="line">  test2_row test2%ROWTYPE;</span><br><span class="line">BEGIN</span><br><span class="line">  OPEN test_cur FOR SELECT * from test1;</span><br><span class="line">  FETCH test_cur INTO test2_row;</span><br><span class="line">EXCEPTION</span><br><span class="line">  WHEN ROWTYPE_MISMATCH THEN</span><br><span class="line">    FETCH test_cur INTO test1_row;</span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(&apos;c1: &apos;||test1_row.c1||&apos; c2: &apos;||test1_row.c2||&apos; c3: &apos;||test1_row.c3);</span><br><span class="line">END;</span><br><span class="line">/</span><br></pre></td></tr></table></figure>

<p>#####6. 游标变量的限制</p>
<ul>
<li>不能在包中声明游标变量</li>
<li>不能在创建表或创建视图的语句中把字段类型指定为<code>REF CURSOR</code>类型，数据库字段是不能存放游标变量值的</li>
<li>游标类型的参数不支持使用远程过程调用（RPC）将游标变量从一个服务器传递到另外一个服务器</li>
<li>不能用比较操作符来判断两个游标之间是否相等或者为NULL</li>
<li>不能为游标变量赋空值</li>
<li>不能将<code>REF CURSOR</code>类型作为集合的元素类型，也就是说在索引表、嵌套表和变长数组中不能存放游标变量的值</li>
<li>不能将在游标中使用的游标FOR循环用在游标变量上，也就是说游标和游标变量不要试图互相替换</li>
</ul>
<p>END</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/10/20/understand-oracle-cursor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Tang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IndigoAxe">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/10/20/understand-oracle-cursor/" itemprop="url">PL/SQL 中的游标(CURSOR) - PART1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-10-20T07:56:51+08:00">
                2015-10-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>######1. 游标是什么</p>
<p>首先我们先来了解一下游标。游标<b>是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果。<br></b> Oracle 在执行SQL语句时，总是需要创建一块内存区域，这块内存区域称为上下文区域。在这个区域中包含了处理语句的信息：</p>
<ul>
<li>指向共享池中被分析SQL语句的指针</li>
<li>查询返回的结果集</li>
<li>当前语句已经处理了多少行</li>
</ul>
<p><img src="/content/images/2015/10/cursor_construct-1.png" alt><br>如图，其中:</p>
<ul>
<li>select语句即是<b>已分析的SQL语句</b></li>
<li>中间的数据内容即是<strong>返回的结果集</strong></li>
<li>“9 rows selected.” 则代表着<b>语句处理的行数</b></li>
</ul>
<p>在进行游标操作的过程中，可以将游标看成是指向数据表中数据的指针，但是在后台，游标实际是指向一块内存区域。而只有在游标被打开后，游标相关的查询语句才会被执行，然后将结果保存到内存中。</p>
<p>#####2. 游标的种类及属性</p>
<p>######2.1 游标种类<br>游标总的来说分为两种，一种是静态游标，另外一种是动态游标。我们可以把静态游标与动态游标分别理解为是常亮与变量的区别。静态游标一经定义就无法被改变，而动态游标可以被灵活地使用。下面来具体介绍它们。</p>
<p>2.1.1 静态游标<br>静态游标</p>
<ul>
<li>显式游标：就是有明确声明来定义的游标，它被定义后，使用时需要显式地打开（open）。</li>
<li>隐式游标：即没有明确声明的游标。所有的DML操作都被Oracle内部解析为一个cursor名为SQL的隐式游标。由于它由Oracle动态创建，因此不能显式地打开和关闭，而是由Oracle来支配。</li>
</ul>
<p>显式游标定义的语法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CURSOR cursor_name [parameter_list]</span><br><span class="line">[RETURN return_type]</span><br><span class="line">IS query</span><br><span class="line">[FOR UPDATE [OF (column_list)][NOWAIT]]</span><br></pre></td></tr></table></figure>

<p>使用示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line">  l_row dba_tables%ROWTYPE;       --保存游标查询结果的记录变量</span><br><span class="line">  CURSOR l_cur                   --定义游标</span><br><span class="line">  IS select * from dba_tables where rownum&lt;10;  </span><br><span class="line">BEGIN</span><br><span class="line">  OPEN l_cur;                    --打开游标</span><br><span class="line">  LOOP </span><br><span class="line">    FETCH l_cur into l_row;      --提取游标内容</span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(&apos;这是第&apos;|| l_cur%ROWCOUNT ||&apos;个表&apos;);</span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(&apos;表名: &apos;|| l_row.table_name);</span><br><span class="line">    EXIT WHEN l_cur%NOTFOUND;     --当游标查询结束后退出循环</span><br><span class="line">  END LOOP;                      </span><br><span class="line">  CLOSE l_cur;                    --关闭游标</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>隐式游标使用简单示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line">  l_num number;</span><br><span class="line">BEGIN</span><br><span class="line">  select count(*) into l_num from dba_tables where 1=2;</span><br><span class="line">  IF SQL%FOUND</span><br><span class="line">  THEN</span><br><span class="line">    dbms_output.put_line(&apos;SQL%ROWCOUNT: &apos;||SQL%ROWCOUNT);</span><br><span class="line">    dbms_output.put_line(&apos;l_num: &apos;||l_num);</span><br><span class="line">  END IF;</span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line">运行后结果：</span><br><span class="line">SQL%ROWCOUNT: 1</span><br><span class="line">l_num: 0</span><br></pre></td></tr></table></figure>

<p>在Oracle中，<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、和<code>SELECT INTO</code>语句在被执行时，都会创建隐式游标。这里并没有显式地声明游标，而是Oracle隐式的创建了游标，并且允许我们通过关键字SQL来访问该游标的属性。</p>
<p>2.1.2 动态游标<br>动态游标又称游标变量。游标变量指向的是一个查询的工作区，不依赖于一个特定的动态的工作区。当一个游标变量指向一个特定的工作区的时候，Oracle会为它保留该存储空间。因此可以在运行时为游标变量赋值，同时还可以作为参数传递给本地和存储过程。<br>静态游标是一个指向具体结果集的常亮，是一个具体的游标对象；而游标变量是一个指向游标对象的指针，它指向具体的游标对象。</p>
<p>动态游标的声明语法如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TYPE cursor_type_name IS REF CURSOR [ RETURN return_type ];</span><br></pre></td></tr></table></figure>

<p>定义示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line">  TYPE l_tab_type IS REF CURSOR RETURN dba_tables%ROWTYPE;</span><br><span class="line">  TYPE l_gen_type IS REFCORSOR;</span><br><span class="line">  l_tab_cur l_tab_type;</span><br><span class="line">  l_gen_cur l_gen_type;</span><br><span class="line">BEGIN</span><br><span class="line">  OPEN l_tab_cur FOR select * from dba_tables where rownum&lt;10;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>如果TYPE语句中未指定RETURN子句，则可以连续地打开多次，分别赋予不同的查询SELECT子句。因此指定了RETURN子句的游标类型又称为强类型游标类型。</p>
<p>NOTE:<br>1) Oracle提供了一个预定义的弱类型游标类型，名为<code>SYS_REFCURSOR</code>。在上面的例子中，可使用<code>SYS_REFCURSOR</code>来代替<code>l_gen_type</code>的定义<code>l_gen_cur SYS_REFCURSOR;</code>。
2) 重新打开一个游标变量以前不需要关闭它，当用不同的查询语句打开同一个游标变量的时候，上一个查询将被丢弃掉。</p>
<p>######2.2 属性<br>通过上面的示例，可以发现其中使用到了一些游标的属性来帮助我们更好的利用游标。下面是游标的主要属性：</p>
<ul>
<li><code>%ISOPEN</code> 用于判断对应游标是否打开</li>
<li><code>%FOUND</code>  用于检查是否从结果集中提取到了数据。在调用<code>FETCH</code>之前，该属性值是<code>NULL</code>。调用<code>FETCH</code>之后该属性的值只能为<code>false</code> 或是 <code>true</code></li>
<li><code>%NOTFOUND</code> 顾名思义，该属性与<code>%FOUND</code>相反</li>
<li><code>%ROWCOUNT</code> 用于返回到目前为止已经从游标中取出的记录的行数，即每<code>fetch</code>成功一次，该值加1。</li>
</ul>
<p><b>注意：</b><br>1） 由于隐式游标会自动关闭，因此<code>SQL%ISOPEN</code>总是为<code>false</code>。 
2） 如果游标没有打开就使用<code>%ISOPEN</code>以外的属性，都将会触发异常。<br>3)   <code>NO_DATA_FOUND</code>和<code>%NOTFOUND</code>的用法是有区别的，小结如下：</p>
<ul>
<li><code>SELECT . . . INTO</code> 语句触发 <code>NO_DATA_FOUND</code></li>
<li>当一个显式光标的 <code>where</code> 子句未找到时触发 <code>%NOTFOUND</code></li>
<li>当<code>UPDATE</code>或<code>DELETE</code> 语句的<code>where</code> 子句未找到时触发 <code>SQL%NOTFOUND</code></li>
<li>在光标的提取(Fetch)循环中要用 <code>%NOTFOUND</code> 或<code>%FOUND</code> 来确定循环的退出条件，不要用<code>NO_DATA_FOUND</code>。</li>
</ul>
<p>#####3、OPEN、FETCH 和CLOSE</p>
<p>######3.1. OPEN<br>定义游标后,在PL/SQL语句块的执行区首先要打开游标。在游标被打开时，将会发生如下所示的几个动作：</p>
<ul>
<li>检验绑定变量的值</li>
<li>基于查询的语句确定游标的活动集</li>
<li>游标指针指向结果集的第一行</li>
</ul>
<p>打开游标的语法为：<code>OPEN cursor_name [(parameter_values</code><br>下面是示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DECLARE</span><br><span class="line">  CURSOR l_tab_cursor (p_rownum IN NUMBER) return dba_tables%ROWTYPE</span><br><span class="line">  IS </span><br><span class="line">    SELECT * FROM dba_tables where rownum&lt;p_rownum;</span><br><span class="line">BEGIN</span><br><span class="line">  OPEN l_tab_cursor (10);  --打开游标并传入参数</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>######3.2 FETCH<br><code>FETCH</code>可以一次一行地提取游标数据。如果想一次性接受所有或部分的结果到一个数组或一个PL/SQL表中，可以使用<code>BULK COLLECT</code>子句。<br><br>FETCH的语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FETCH cursor_name [BULK COLLECT] INTO variable_name(s) | PL/SQL_record [LIMIT limit_num];</span><br></pre></td></tr></table></figure>

<p>BULK COLLECT LIMIT 使用示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">--根据dba_tables前二十条记录(rownum&lt;20)中的table_name（以一行四个的格式）。</span><br><span class="line">DECLARE</span><br><span class="line">  TYPE l_dbatab_type IS VARRAY(4) OF dba_tables%ROWTYPE;  --定义变长数组类型</span><br><span class="line">  l_dbatab_tab l_dbatab_type;                              --定义变长数组变量</span><br><span class="line">  CURSOR l_dbatab_cur</span><br><span class="line">  IS</span><br><span class="line">    SELECT * FROM dba_tables where rownum&lt;20;</span><br><span class="line">  l_rows INT :=4;                                         --LIMIT行数</span><br><span class="line">  l_count INT :=0;                                        --计数器</span><br><span class="line">BEGIN</span><br><span class="line">  OPEN l_dbatab_cur;</span><br><span class="line">  LOOP </span><br><span class="line">    --每次提取四行数据到变长数组中</span><br><span class="line">    FETCH l_dbatab_cur BULK COLLECT INTO l_dbatab_tab LIMIT l_rows;</span><br><span class="line">    EXIT WHEN l_dbatab_cur%NOTFOUND;</span><br><span class="line">    DBMS_OUTPUT.PUT(&apos;Table name is: &apos;) ;</span><br><span class="line">    FOR i IN 1 .. (l_dbatab_cur%ROWCOUNT - l_count)</span><br><span class="line">    LOOP</span><br><span class="line">      DBMS_OUTPUT.PUT(l_dbatab_tab(i).table_name||&apos; &apos;); --输出表名</span><br><span class="line">    END LOOP;</span><br><span class="line">    DBMS_OUTPUT.NEW_LINE;</span><br><span class="line">    l_count := l_dbatab_cur%ROWCOUNT;   --更新计数器 </span><br><span class="line">  END LOOP;</span><br><span class="line">  CLOSE l_dbatab_cur;</span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">Table name is: OBJ$ CCOL$ CLU$ SEG$</span><br><span class="line">Table name is: ICOL$ FILE$ IND$ CON$</span><br><span class="line">Table name is: UET$ TS$ CDEF$ FET$</span><br><span class="line">Table name is: PROXY_DATA$ BOOTSTRAP$ COL$ TAB$</span><br></pre></td></tr></table></figure>

<p>######3.3 CLOSE<br>使用完游标后应立即关闭它，以利于相关资源回收。关闭游标的语法很简单：<br><br><code>CLOSE cursor_name;</code></p>
<p>TO BE CONTINUE…</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/10/13/topshi-yong-ji-qiao/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Tang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IndigoAxe">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/10/13/topshi-yong-ji-qiao/" itemprop="url">TOP命令学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-10-13T05:59:29+08:00">
                2015-10-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>######目录<br><a href="#1">一、命令简介</a><br><br><a href="#2">二、批处理OR交互模式？</a><br><br><a href="#3">三、定制输出内容</a><br><br><a href="#4">四、更新频率是快是慢？</a><br><br><a href="#5">五、”我的Linux主机上怎么会只有很少的空闲内存?”</a></p>
<h6 id="1">一、命令简介</h6>
TOP命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况。 

<p><b>1.使用格式</b>：
<code>top [-] [d] [p] [q] [c] [C] [S] [s] [n]</code><br>参数说明:<br><br>d：  指定每两次屏幕信息刷新之间的时间间隔。当然用户可以使用s交互命令来改变之。<br>p：  通过指定监控进程ID来仅仅监控某个进程的状态。<br>q：该选项将使top没有任何延迟的进行刷新。如果调用程序有超级用户权限，那么top将以尽可能高的优先级运行。<br>S： 指定累计模式<br>s ： 使top命令在安全模式中运行。这将去除交互命令所带来的潜在危险。<br>i：  使top不显示任何闲置或者僵死进程。<br>c：  显示整个命令行而不只是显示命令名</p>
<p><b>2.统计信息详解</b></p>
<p><b>执行命令结果：</b><br></p>
<pre>top - 15:22:45 up  4:19,  5 users,  load average: 0.00, 0.03, 0.00
Tasks:  60 total,   1 running,  59 sleeping,   0 stopped,   0 zombie
Cpu(s):  3.8% us,  2.9% sy,  0.0% ni, 89.6% id,  3.3% wa,  0.4% hi,  0.0% si
Mem:    515896k total,   495572k used,    20324k free,    13936k buffers
Swap:   909676k total,        4k used,   909672k free,   377608k cached
PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
  1 root      16   0  1544  476  404 S  0.0  0.1   0:01.35 init
  2 root      34  19     0    0    0 S  0.0  0.0   0:00.02 ksoftirqd/0
  3 root      10  -5     0    0    0 S  0.0  0.0   0:00.11 events/0 
</pre>

<p>统计信息区前五行是系统整体的统计信息。第一行是任务队列信息，同 uptime  命令的执行结果:</p>
<pre>$ uptime
 13:22:30 up 8 min,  4 users,  load average: 0.14, 0.38, 0.25
</pre>
<p><b>其解析如下：</b></p>
<table class="t_table" cellspacing="0">
<tbody>
<tr>
<td>01:06:48</td>
<td>当前时间</td>
</tr>
<tr>
<td>up 1:22</td>
<td>系统运行时间，格式为时:分</td>
</tr>
<tr>
<td>1 user</td>
<td>当前登录用户数</td>
</tr>
<tr>
<td>load average: 0.06, 0.60, 0.48</td>
<td>系统负载，即任务队列的平均长度.<br>三个数值分别为&nbsp;&nbsp;1分钟、5分钟、15分钟前到现在的平均值.</td>
</tr>
</tbody>
</table>
<b><span>第二、三行为进程和CPU的信息,当有多个CPU时，这些内容可能会超过两行.内容如下：</span></b>
<table>
<tbody>
<tr>
<td>Tasks: 29 total</td>
<td>进程总数</td>
</tr>
<tr>
<td>1 running</td>
<td>正在运行的进程数</td>
</tr>
<tr>
<td>28 sleeping</td>
<td>睡眠的进程数</td>
</tr>
<tr>
<td>0 stopped</td>
<td>停止的进程数</td>
</tr>
<tr>
<td>0 zombie</td>
<td>僵尸进程数</td>
</tr>
<tr>
<td>Cpu(s): 0.3% us</td>
<td>用户空间占用CPU百分比</td>
</tr>
<tr>
<td>1.0% sy</td>
<td>内核空间占用CPU百分比</td>
</tr>
<tr>
<td>0.0% ni</td>
<td>用户进程空间内改变过优先级的进程占用CPU百分比</td>
</tr>
<tr>
<td>98.7% id</td>
<td>空闲CPU百分比</td>
</tr>
<tr>
<td>0.0% wa</td>
<td>等待输入输出的CPU时间百分比</td>
</tr>
<tr>
<td>0.0% hi</td>
<td>&nbsp;CPU服务于硬中断所耗费的时间总额</td>
</tr>
<tr>
<td>0.0% si、0.0%st</td>
<td>&nbsp;CPU服务于软中断所耗费的时间总额、Steal Time</td>
</tr>
</tbody>
</table>
<b><span>最后两行为内存信息。内容如下：</span></b>
<table class="t_table" cellspacing="0">
<tbody>
<tr>
<td>Mem: 191272k total</td>
<td>物理内存总量</td>
</tr>
<tr>
<td>173656k used</td>
<td>使用的物理内存总量</td>
</tr>
<tr>
<td>17616k free</td>
<td>空闲内存总量</td>
</tr>
<tr>
<td>22052k buffers</td>
<td>用作内核缓存的内存量</td>
</tr>
<tr>
<td>Swap: 192772k total</td>
<td>交换区总量</td>
</tr>
<tr>
<td>0k used</td>
<td>使用的交换区总量</td>
</tr>
<tr>
<td>192772k free</td>
<td>空闲交换区总量</td>
</tr>
<tr>
<td>123988k cached</td>
<td>缓冲的交换区总量.<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;内存中的内容被换出到交换区,而后又被换入到内存,但使用过的交换区尚未被覆盖,<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;该数值即为这些内容已存在于内存中的交换区的大小.<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;相应的内存再次被换出时可不必再对交换区写入.</td>
</tr>
</tbody>
</table>
<b><br><span>进程信息区统计信息区域的下方显示了各个进程的详细信息。
首先来认识一下各列的含义：</span></b>
<table class="t_table" cellspacing="0">
<tbody>
<tr>
<td>序号</td>
<td>列名</td>
<td>含义</td>
</tr>
<tr>
<td>1</td>
<td>PID</td>
<td>进程id</td>
</tr>
<tr>
<td>2</td>
<td>PPID</td>
<td>父进程id</td>
</tr>
<tr>
<td>3</td>
<td>RUSER</td>
<td>Real user name</td>
</tr>
<tr>
<td>4</td>
<td>UID</td>
<td>进程所有者的用户id</td>
</tr>
<tr>
<td>5</td>
<td>USER</td>
<td>进程所有者的用户名</td>
</tr>
<tr>
<td>6</td>
<td>GROUP</td>
<td>进程所有者的组名</td>
</tr>
<tr>
<td>7</td>
<td>TTY</td>
<td>启动进程的终端名.不是从终端启动的进程则显示为 ?</td>
</tr>
<tr>
<td>8</td>
<td>PR</td>
<td>优先级</td>
</tr>
<tr>
<td>9</td>
<td>NI</td>
<td>nice值.负值表示高优先级，正值表示低优先级</td>
</tr>
<tr>
<td>10</td>
<td>P</td>
<td>最后使用的CPU,仅在多CPU环境下有意义</td>
</tr>
<tr>
<td>11</td>
<td>%CPU</td>
<td>上次更新到现在的CPU时间占用百分比</td>
</tr>
<tr>
<td>12</td>
<td>TIME</td>
<td>进程使用的CPU时间总计,单位秒</td>
</tr>
<tr>
<td>13</td>
<td>TIME+</td>
<td>进程使用的CPU时间总计,单位1/100秒</td>
</tr>
<tr>
<td>14</td>
<td>%MEM</td>
<td>进程使用的物理内存百分比</td>
</tr>
<tr>
<td>15</td>
<td>VIRT</td>
<td>进程使用的虚拟内存总量,单位kb,VIRT=SWAP+RES</td>
</tr>
<tr>
<td>16</td>
<td>SWAP</td>
<td>进程使用的虚拟内存中,被换出的大小,单位kb.</td>
</tr>
<tr>
<td>17</td>
<td>RES</td>
<td>进程使用的、未被换出的物理内存大小,单位kb,RES=CODE+DATA</td>
</tr>
<tr>
<td>18</td>
<td>CODE</td>
<td>可执行代码占用的物理内存大小,单位kb</td>
</tr>
<tr>
<td>19</td>
<td>DATA</td>
<td>可执行代码以外的部分(数据段+栈)占用的物理内存大小,单位kb</td>
</tr>
<tr>
<td>20</td>
<td>SHR</td>
<td>共享内存大小,单位kb</td>
</tr>
<tr>
<td>21</td>
<td>nFLT</td>
<td>页面错误次数</td>
</tr>
<tr>
<td>22</td>
<td>nDRT</td>
<td>最后一次写入到现在,被修改过的页面数.</td>
</tr>
<tr>
<td>23</td>
<td>S</td>
<td>进程状态:<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>D</strong>=不可中断的睡眠状态<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>R</strong>=运行<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>S</strong>=睡眠<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>T</strong>=跟踪/停止<br>&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<strong>Z</strong>=僵尸进程</td>
</tr>
<tr>
<td>24</td>
<td>COMMAND</td>
<td>命令名/命令行</td>
</tr>
<tr>
<td>25</td>
<td>WCHAN</td>
<td>若该进程在睡眠,则显示睡眠中的系统函数名</td>
</tr>
<tr>
<td>26</td>
<td>Flags</td>
<td>任务标志,参考 sched.h</td>
</tr>
</tbody>
</table>
<p><br><span>　　默认情况下仅显示比较重要的&nbsp;&nbsp;PID、USER、PR、NI、VIRT、RES、SHR、S、%CPU、%MEM、TIME+、COMMAND &nbsp;几个列。</span></p>
<p><span>　　可以通过下面的快捷键来更改显示内容：</span><br><span>　　更改显示内容通过&nbsp;</span><strong>f&nbsp;</strong><span>键可以选择显示的内容（按 f 键之后会显示列的列表，按 a-z&nbsp;&nbsp;即可显示或隐藏对应的列，最后按回车键确定）</span><br><span>　　按&nbsp;</span><strong>o</strong><span>&nbsp;键可以改变列的显示顺序（按小写的 a-z 可以将相应的列向右移动，而大写的 A-Z&nbsp;&nbsp;可以将相应的列向左移动，最后按回车键确定）</span><br><span>　　按大写的&nbsp;</span><strong>F</strong><span>&nbsp;或&nbsp;</span><strong>O</strong><span>&nbsp;键，然后按 a-z 可以将进程按照相应的列进行排序，而大写的&nbsp;&nbsp;</span><strong>R</strong><span>&nbsp;键可以将当前的排序倒转.</span></p>

<h6 id="2">二、批处理OR交互模式</h6>
TOP默认为交互模式。若需要对TOP的输出进行处理，可以使用批处理模式。
<code>$top -b</code>
但是该命令将会不断重复打印系统实时状态。如果需要限制次数，可以使用：<br>
<code>$top -b -n 1</code>
批处理模式可以方便地与<code>at</code>和<code>cron</code>结合使用：
<pre>$ cat ./test.at
TERM=linux top -b -n 1 >/tmp/top-report.txt
$ at -f ./test.at now+1minutes</pre>
注：在TOP命令前设置TERM变量是为了保证其正常运行。因为TOP运行时需要它，而at命令在定时调用时不会保留TERM变量。

<h6 id="3">三、定制输出内容</h6>

<p>有时，我们只对几个进程感兴趣，可能只是全部进程中的4个或5个。例如，如果你想要监测进程标识（PID）为4360和4358的进程，你需要键入：</p>
<pre>$ top -p 4360,4358
$ top -p 4360 -p 4358</pre>
<p>看起来很简单，只需要使用 -p 列出所有需要的 PID，并使用逗号间隔或简单的多次使用 -p即可。<br>另一种可能是监测拥有特定用户标识（UID）的进程。应对此需求，你可以使用 -u 或 -U 选项。假设用户“johndoe”的 UID 为500，键入：</p>
<pre>$ top -u johndoe
$ top -u 500
$ top -U johndoe</pre>
<p>结论是，你既可以纯使用用户名，也可使用数字 UID。“-u，-U？这两者不同？”是的。同多数其它 GNU 工具一样，选项是大小写敏感的。-U 意味着 Top 将会搜索有效的、真实的、被保存的以及文件系统的 UID 进行匹配，而 -u 仅匹配有效的用户id。要知道，每一个 *nix 进程在运行时都是用有效用户标识（effective UID），而其中有些并不等同真实用户标识。多数情况是，对类似文件系统权限或操作系统功能这项的有效用户标识感兴趣的人将会检查它，而不是 UID。<br>不同于 -p 仅用于命令行选项，-U 和 -u 都可以在交互模式中使用。同你猜测的一样，键入‘U’或‘u’可以依据用户名过滤进程。同样的规则依然适用，‘u’为有效用户标识，‘U’为 真实/有效/保存/文件系统用户名。你将被要求键入用户名或数字 UID。</p>
<h6 id="4">四、更新频率是快是慢？</h6>
在回答这个问题之前，让我们先简单介绍一下，Top 是如何运行的。这里，Strace 能够帮助你：
<pre>$ strace -o /tmp/trace.txt top -b -n </pre>
使用你偏爱的文本编辑器打开 `/tmp/trace.txt`。你怎么想？一次调用有太多的活要做了，反正我是这么想的。Top 在每次遍历中必做的工作之一就是打开很多文件，并解析其内容，可以看看次数：
<pre>$ grep open /tmp/hasil.txt | wc -l</pre>
举例而言，我的 Linux 中，这个数量是304.仔细观察就会发现，Top 遍历 `/proc` 文件夹，以收集进程信息。`/proc` 本身是一个虚拟文件系统，意味着它并非存在于真实硬盘之中，而是由 Linux 内核凭空创建，保存在内存中的。在文件夹中，如`/proc/2097`（2097为 PID），Linux 内核将与之关联的信息打印到此文件中，而这里就是 Top 的消息来源。
同时试一下：
<pre>$ time top -b -n 1</pre>
这样你就能了解到 Top 单轮工作有多快了。在我的系统中，大约为0.5-0.6秒。看“real”字段，不是“user”或“system”字段，因为“real”字段反应了 Top 工作需要的总时间。
所以，有了这个认知之后，使用适度的更新间隔是明智的。基于文件系统访问内存也是需要时间的。经验法则是，对于多数用户来说，1到3秒的间隔就足够了。在命令行中使用-d，或在交互模式下按下“s”以设置。你可以使用类似2.5,4.1这样的小树。
什么时候我们需要快于1秒的更新？
时间段内需要更多的样本。应对这点要求，最好使用批处理模式，并将标准输出重定向到文件中，以便更好的分析。
你并不在意 Top 消耗的额外CPU负荷。是的，虽然它很小，它依然需要负荷。如果你的 Linux 系统相对比较空闲，随意使用短间隔，如果不是，最好为重要的任务保留你的 CPU 时间。
一个减少 Top 工作的办法是只监测特定的几个 PID。这样，Top 无需遍历 /proc 下所有的子文件夹。用户名过滤呢？并不会变得更好。用户名过滤会给Top带来额外工作量，因此将其与短间隔联合将会增加 CPU 负荷。
当然，当你需要强制更新时，按下 Space 键，Top 将会刷新统计。

<h6 id="5">五、"我的Linux主机上怎么会只有很少的空闲内存?"</h6>

<p>有同样的问题? 不管你在主板上增加多少内存，你都会很快发现空闲内存减少的非常迅速. 空闲内存算错了? 不!
在回答这个之前, 先查看一下top命令顶部显示的内存概要 (有可能你需要按 ‘m’来显示出来)。在这里，你可以看到两个区域: 缓冲（buffers）和缓存（cached）。 “缓冲（Buffers）” 代表有多少内存用来缓存磁盘块 “缓存（Cached）” 有一点类似 “缓冲（Buffers）”, 只是仅仅从文件读取缓存页面. 想透彻了解这部分,建议读一下Linux内核的书比如Robert M.Love写的《Linux Kernel Development》。</p>
<p>这足够了解缓冲（buffers）和缓存（cached)代表系统缓存. 他们会根据linux内核机制动态增加或减少。<br>除去被缓存的消耗，程序和代码同样要占据RAM. 所以，最终空闲内存显示的是RAM中不被缓存和程序/代码占用的部分 一般来说，你也可以考虑缓存区域为另一部分“空闲”RAM，如果程序需要更多内存它会减少<br>从进程的角度来看，你可能想知道哪个区域代表真实的内存消耗，VIRT（virtual memory usage ）区域? 当然不是! 回顾一下，这个区域代表了进程地址空间里一切，包括相关的库。阅读top命令的源代码和proc.txt (在内核代码树中的Documentation/filesystem 文件夹内), 我的结论是RSS字段是进程内存消耗的最好的描述.我说“最好的”是因为你可以考虑它是近似而不是所有时间100%准确。</p>
<p>以上内容部分转自：<a href="http://www.oschina.net/translate/using-top-more-efficiently" target="_blank" rel="noopener">《高效地使用 top》</a><br></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Alex Tang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alex Tang</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
