<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="第二周课程的主要内容是：1. 三大函数：拷贝构造，拷贝赋值，析构2. 堆，栈与内存管理3. 复习string类的实现过程4. 扩展补充：类模板，函数模板，及其他  ==三大函数：拷贝构造，拷贝赋值，析构== 关于这三大函数的介绍，下面内容来自《高质量C++/C编程指南》-第9章-类的构造函数、析构函数与赋值函数的介绍和分析： &amp;gt;构造函数、析构函数与赋值函数是每个类最基本的函数。它们太普通以致让人容">
<meta property="og:type" content="article">
<meta property="og:title" content="C++面向对象高级编程（上） part.2">
<meta property="og:url" content="http://yoursite.com/2018/05/19/cmian-xiang-dui-xiang-gao-ji-bian-cheng-shang-part-2/index.html">
<meta property="og:site_name" content="IndigoAxe">
<meta property="og:description" content="第二周课程的主要内容是：1. 三大函数：拷贝构造，拷贝赋值，析构2. 堆，栈与内存管理3. 复习string类的实现过程4. 扩展补充：类模板，函数模板，及其他  ==三大函数：拷贝构造，拷贝赋值，析构== 关于这三大函数的介绍，下面内容来自《高质量C++/C编程指南》-第9章-类的构造函数、析构函数与赋值函数的介绍和分析： &amp;gt;构造函数、析构函数与赋值函数是每个类最基本的函数。它们太普通以致让人容">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/content/images/2018/05/QQ--20180519154500-2.png">
<meta property="og:image" content="http://yoursite.com/content/images/2018/05/7651004135.jpg">
<meta property="og:image" content="http://yoursite.com/content/images/2018/05/new.jpg">
<meta property="og:image" content="http://yoursite.com/content/images/2018/05/delete.jpg">
<meta property="og:image" content="http://yoursite.com/content/images/2018/05/static-1.jpg">
<meta property="og:updated_time" content="2018-05-20T00:22:03.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++面向对象高级编程（上） part.2">
<meta name="twitter:description" content="第二周课程的主要内容是：1. 三大函数：拷贝构造，拷贝赋值，析构2. 堆，栈与内存管理3. 复习string类的实现过程4. 扩展补充：类模板，函数模板，及其他  ==三大函数：拷贝构造，拷贝赋值，析构== 关于这三大函数的介绍，下面内容来自《高质量C++/C编程指南》-第9章-类的构造函数、析构函数与赋值函数的介绍和分析： &amp;gt;构造函数、析构函数与赋值函数是每个类最基本的函数。它们太普通以致让人容">
<meta name="twitter:image" content="http://yoursite.com/content/images/2018/05/QQ--20180519154500-2.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/05/19/cmian-xiang-dui-xiang-gao-ji-bian-cheng-shang-part-2/">





  <title>C++面向对象高级编程（上） part.2 | IndigoAxe</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">IndigoAxe</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/19/cmian-xiang-dui-xiang-gao-ji-bian-cheng-shang-part-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Tang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IndigoAxe">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C++面向对象高级编程（上） part.2</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-19T03:12:00+08:00">
                2018-05-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>第二周课程的主要内容是：<br><br><a href="#1">1. 三大函数：拷贝构造，拷贝赋值，析构</a><br><br><a href="#2">2. 堆，栈与内存管理</a><br><br><a href="#3">3. 复习string类的实现过程</a><br><br><a href="#4">4. 扩展补充：类模板，函数模板，及其他</a></p>
<hr>
<h4 id="1">==三大函数：拷贝构造，拷贝赋值，析构==</h4>
关于这三大函数的介绍，下面内容来自《高质量C++/C编程指南》-第9章-类的构造函数、析构函数与赋值函数的介绍和分析：
>构造函数、析构函数与赋值函数是每个类最基本的函数。它们太普通以致让人容易麻痹大意，其实这些貌似简单的函数就象没有顶盖的下水道那样危险。 每个类只有一个析构函数和一个赋值函数，但可以有多个构造函数（包含一个拷贝构造函数，其它的称为普通构造函数）。对于任意一个类A，如果不想编写上述函数，C++编译器将自动为A产生四个缺省的函数，如
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A(void); // 缺省的无参数构造函数</span><br><span class="line">A(const A &amp;a); // 缺省的拷贝构造函数</span><br><span class="line">~A(void); // 缺省的析构函数</span><br><span class="line">A &amp; operate =(const A &amp;a); // 缺省的赋值函数</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这不禁让人疑惑，既然能自动生成函数，为什么还要程序员编写？<br>原因如下：<br><br>（1）如果使用“缺省的无参数构造函数”和“缺省的析构函数”，等于放弃了自主“初始化”和“清除”的机会，C++发明人Stroustrup的好心好意白费了。<br><br>（2）“缺省的拷贝构造函数”和“缺省的赋值函数”==均采用“位拷贝”而非“值拷贝”的方式来实现，倘若类中含有指针变量，这两个函数注定将出错。==<br><br>对于那些没有吃够苦头的C++程序员，如果他说编写构造函数、析构函数与赋值函数很容易，可以不用动脑筋，表明他的认识还比较肤浅，水平有待于提高。<br>本章以类String的设计与实现为例，深入阐述被很多教科书忽视了的道理。String的结构如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class String</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">String(const char *str = NULL); // 普通构造函数</span><br><span class="line">String(const String &amp;other); // 拷贝构造函数</span><br><span class="line">~ String(void); // 析构函数</span><br><span class="line">String &amp; operate =(const String &amp;other); // 赋值函数</span><br><span class="line">private:</span><br><span class="line">char *m_data; // 用于保存字符串</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>==<strong>下面是侯老师讲课的时候强调的一些重要的点</strong>==</p>
<ul>
<li><p><strong>如果对象是带指针成员变量的，一定要自定义这三大函数。如果使用默认拷贝函数，会导致浅拷贝出现，从而导致内存泄漏。因为被赋值的指针原来所指向的内存没有被释放，而且再也没有指针指向它。如下图：</strong><br><img src="/content/images/2018/05/QQ--20180519154500-2.png" alt="copyctor"></p>
</li>
<li><p><strong>尽量使用指针来定义类中的成员变量，而不是直接存储变量的值。</strong>（如上面代码中的*m_date）</p>
</li>
<li><p><strong>函数传入一个指针时，记住要先判断它是否是空指针。而传引用则不用。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">inline</span><br><span class="line">String::String(const char* cstr)</span><br><span class="line">&#123;  </span><br><span class="line">   // 因为传入的是指针，所以需要检测它是否为空指针。</span><br><span class="line">   if (cstr) &#123;</span><br><span class="line">      m_data = new char[strlen(cstr)+1];</span><br><span class="line">      strcpy(m_data, cstr);</span><br><span class="line">   &#125;</span><br><span class="line">   else &#123;   </span><br><span class="line">      m_data = new char[1];</span><br><span class="line">      *m_data = &apos;\0&apos;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>对于指向对象的指针，离开其作用域前，一定要注意用delete释放该指针。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    string s1(&quot;hello&quot;);</span><br><span class="line">    string s2(&quot;world&quot;);</span><br><span class="line"></span><br><span class="line">    string *p = new string(&quot;geekband&quot;);</span><br><span class="line">    delete p;//离开作用域前要释放指针</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>拷贝构造函数和拷贝赋值函数的区别，以及拷贝赋值函数需要注意的地方：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">inline</span><br><span class="line">String&amp; String::operator=(const String&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">   // 检测是否是自我赋值， 如果不检测自我赋值，会导致strcpy出现未定义的行为（原来的指针已经被删除）</span><br><span class="line">   if (this == &amp;str)</span><br><span class="line">      return *this;</span><br><span class="line">   // 需要先释放原来已分配的内存，然后再重新分配一块新的</span><br><span class="line">   delete[] m_data;</span><br><span class="line">   m_data = new char[ strlen(str.m_data) + 1 ];</span><br><span class="line">   strcpy(m_data, str.m_data);</span><br><span class="line">   return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline</span><br><span class="line">String::String(const String&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">   m_data = new char[ strlen(str.m_data) + 1 ];</span><br><span class="line">   strcpy(m_data, str.m_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h4 id="2">==堆，栈与内存管理==</h4>
来源：http://www.cnblogs.com/heyonggang/p/3250220.html

<ul>
<li><strong>c++ 的内存分配</strong></li>
</ul>
<p>　　在一些资料中是这样定义C++内存分配的，可编程内存在基本上分为这样的几大部分：静态存储区、堆区和栈区。他们的功能不同，对他们使用方式也就不同。</p>
<p>　　a)静态存储区：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据、全局数据和常量。</p>
<p>　　b)栈区：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p>
<p>　　c)堆区：亦称动态内存分配。程序在运行的时候用malloc或new申请任意大小的内存，程序员自己负责在适当的时候用free或delete释放内存。动态内存的生存期可以由我们决定，如果我们不释放内存，程序将在最后才释放掉动态内存。 <strong>但是，良好的编程习惯是：如果某动态内存不再使用，需要将其释放掉，否则，我们认为发生了内存泄漏现象。</strong></p>
<p>　　全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的 C 语言中，全局变量又分为初始化的和未初始化的（初始化的全局变量和静态变量在一块区域，未初始化的全局变量与静态变量在相邻的另一块区域，同时未被初始化的对象存储区可以通过 void* 来访问和操纵，程序结束后由系统自行释放），在 C++ 里面没有这个区分了，他们共同占用同一块内存区。</p>
<p>　　常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改（当然，你要通过非正当手段也可以修改，而且方法很多）<br><img src="/content/images/2018/05/7651004135.jpg" alt="classic_memory"></p>
<ul>
<li><strong>堆与栈区别</strong></li>
</ul>
<p>我们先通过例子1来直观的说明下栈与堆内存的区别，然后在细致分析例子2中的情况。</p>
<p>　　例子1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> void fn()&#123; </span><br><span class="line">     int* p = new int[5]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　看到new，首先应该想到，我们分配了一块堆内存，那么指针p呢? 它分配的是一块栈内存，所以这句话的意思就是:在栈内存中存放了一个指向一块堆内存的指针p。程序会先确定在堆中分配内存的大小，然后调用 operator new分配内存，然后返回这块内存的首地址，放入栈中。</p>
<p>　　注意：这里为了简单并没有释放内存，那么该怎么去释放呢? 是deletep么? NO，错了，应该是delete [ ] p，这是告诉编译器:删除的是一个数组。</p>
<p>例子2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int a = 0; //全局初始化区</span><br><span class="line">char *p1; //全局未初始化区</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int b; //栈 </span><br><span class="line">   char s[] = &quot;abc&quot;; //栈 </span><br><span class="line">   char *p2; //栈 </span><br><span class="line">   char *p3 = &quot;123456&quot;; // 123456\0在常量区，p3在栈上。 </span><br><span class="line">   static int c =0; //全局(静态)初始化区 </span><br><span class="line">   p1 = (char *)malloc(10); </span><br><span class="line">   p2 = (char *)malloc(20); 12: //分配得来得10和20字节的区域就在堆区。 </span><br><span class="line">   strcpy(p1, &quot;123456&quot;); //123456\0放在常量区，编译器可能会将它与p3所指向的&quot;123456&quot;优化成一个地方。 </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>例子3：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">char* f1() </span><br><span class="line">&#123; </span><br><span class="line">    char* p = NULL; </span><br><span class="line">    char a; </span><br><span class="line">    p = &amp;a;</span><br><span class="line">    return p; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">char* f2() </span><br><span class="line">&#123; </span><br><span class="line">    char* p = NULL;</span><br><span class="line">    p =(char*) new char[4]; </span><br><span class="line">    return p; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这两个函数都是将某个存储空间的地址返回，二者有何区别呢?f1()函数虽然返回的是一个存储空间，但是此空间为临时空间。也就是说，此空间只 有短暂的生命周期，它的生命周期在函数f1()调用结束时，也就失去了它的生命价值，即：此空间被释放掉。所以，当调用f1()函数时，如果程序中有下面的语句：</p>
<p>　　<code>char* p ; p = f1(); *p = ‘a’;</code></p>
<p>　　此时，编译并不会报告错误，但是在程序运行时，会发生异常错误。因为，你对不应该操作的内存(即，已经释放掉的存储空间)进行了操作。但是，相 比之下，f2()函数不会有任何问题。因为，new这个命令是在堆中申请存储空间，一旦申请成功，除非你将其delete或者程序终结，这块内存将一直存 在。也可以这样理解，堆内存是共享单元，能够被多个函数共同访问。如果你需要有多个数据返回却苦无办法，堆内存将是一个很好的选择。但是一定要避免下面的 事情发生：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　void f()&#123; </span><br><span class="line">    … </span><br><span class="line">    char * p; </span><br><span class="line">    p = (char*)new char[100]; </span><br><span class="line">    … </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这个程序做了一件很无意义并且会带来很大危害的事情。因为，虽然申请了堆内存，p保存了堆内存的首地址。但是，此变量是临时变量，当函数调用结 束时p变量消失。也就是说，再也没有变量存储这块堆内存的首地址，我们将永远无法再使用那块堆内存了。但是，这块堆内存却一直标识被你所使用(因为没有到 程序结束，你也没有将其delete，所以这块堆内存一直被标识拥有者是当前您的程序)，进而其他进程或程序无法使用。我们将这种不道德的“流氓行为” (我们不用，却也不让别人使用)称为内存泄漏(memory leak)。</p>
<p>　　综合以上两个例子，我们可以总结一下堆与栈到底有哪些区别:</p>
<p>　　<strong>(1)管理方式不同</strong></p>
<p>　　对于栈来讲，是由编译器自动管理，无需我们手工控制;对于堆来说，释放工作由程序员控制，容易产生memory leak。</p>
<p>　　<strong>(2)空间大小不同</strong></p>
<p>　　空间大小:一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6.0下面默认的栈空间大小是1M,可以修改这个值。</p>
<p>　　<strong>(3)能否产生碎片不同</strong></p>
<p>　　对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题， 因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出。</p>
<p>　　<strong>(4)生长方向不同</strong></p>
<p>　　对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向;对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。(详见第一部分的内存分配图)</p>
<p>　　<strong>(5)分配方式不同</strong></p>
<p>　　堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</p>
<p>　　<strong>(6)分配效率不同</strong></p>
<p>　　栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比 较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法(具体的算法可以参考数据结构/操作系统)在堆 内存中搜索可用的足够大小的空间，如果没有足够大小的空间(可能是由于内存碎片太多)，就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分 到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</p>
<p>　　<strong>==总结：==</strong></p>
<p>　　堆和栈相比，由于大量new/delete的使用，容易造成大量的内存碎片;由于没有专门的系统支持，效率很低;由于可能引发用户态和核心态的 切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP和局部变 量都采用栈的方式存放。所以，推荐大家尽量用栈，而不是用堆。</p>
<p>　　虽然栈有如此众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。</p>
<p>　　无论是堆还是栈，都要防止越界现象的发生(除非你是故意使其越界)，因为越界的结果要么是程序崩溃，要么是摧毁程序的堆、栈结构，产生以想不到 的结果,就算是在你的程序运行过程中，没有发生上面的问题，你还是要小心，说不定什么时候就崩掉，那时候debug可是相当困难。</p>
<ul>
<li><p><strong>其他需要注意的点</strong></p>
<ol>
<li>new操作符是先分配memory,再调用构造函数。而delete操作符则是先调用析构函数再释放memory。注意下面两张图中编译器对new/delete操作符的转化。<br><img src="/content/images/2018/05/new.jpg" alt="new"><br><img src="/content/images/2018/05/delete.jpg" alt="delete"></li>
</ol>
<p>2.array new一定要搭配array delete(delete [])。delete[]可以释放array所占用的内存，并且调用所有元素的析构函数。而delete只会调用第一个元素的析构函数，可能会造成其他元素的内存泄漏。</p>
<p>3.静态函数只能处理静态数据，因为它没有this指针的传入。<br><img src="/content/images/2018/05/static-1.jpg" alt="static"></p>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/18/cmian-xiang-dui-xiang-gao-ji-bian-cheng-shang-part-1/" rel="next" title="C++面向对象高级编程（上）  part.1">
                <i class="fa fa-chevron-left"></i> C++面向对象高级编程（上）  part.1
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/23/cmian-xiang-dui-xiang-gao-ji-bian-cheng-shang-part-3/" rel="prev" title="C++面向对象高级编程（上） part.3">
                C++面向对象高级编程（上） part.3 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Alex Tang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#1"><span class="nav-number">1.</span> <span class="nav-text">==三大函数：拷贝构造，拷贝赋值，析构==</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2"><span class="nav-number">2.</span> <span class="nav-text">==堆，栈与内存管理==</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alex Tang</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
