<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>[GeekBand] C++设计模式 part.1 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1. 设计模式简介2. 面向对象设计原则3. Template Method 模板方法模式4. Strategy 策略模式5. Observer/Event 观察者/事件模式6. Decorator 装饰模式7. Bridge 桥模式   设计模式简介设计模式/软件设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代">
<meta property="og:type" content="article">
<meta property="og:title" content="[GeekBand] C++设计模式 part.1">
<meta property="og:url" content="http://yoursite.com/2016/07/11/geekband-cshe-ji-mo-shi-part-1/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1. 设计模式简介2. 面向对象设计原则3. Template Method 模板方法模式4. Strategy 策略模式5. Observer/Event 观察者/事件模式6. Decorator 装饰模式7. Bridge 桥模式   设计模式简介设计模式/软件设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2016-07-11T21:54:29.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[GeekBand] C++设计模式 part.1">
<meta name="twitter:description" content="1. 设计模式简介2. 面向对象设计原则3. Template Method 模板方法模式4. Strategy 策略模式5. Observer/Event 观察者/事件模式6. Decorator 装饰模式7. Bridge 桥模式   设计模式简介设计模式/软件设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-geekband-cshe-ji-mo-shi-part-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/11/geekband-cshe-ji-mo-shi-part-1/" class="article-date">
  <time datetime="2016-07-11T06:03:28.000Z" itemprop="datePublished">2016-07-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      [GeekBand] C++设计模式 part.1
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="#1">1. 设计模式简介</a><br><a href="#2">2. 面向对象设计原则</a><br><a href="#3">3. Template Method 模板方法模式</a><br><a href="#4">4. Strategy 策略模式</a><br><a href="#5">5. Observer/Event 观察者/事件模式</a><br><a href="#6">6. Decorator 装饰模式</a><br><a href="#7">7. Bridge 桥模式</a>  </p>
<h4 id="1">设计模式简介</h4><br>设计模式/软件设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。<br><br><strong>设计模式的要点:</strong><br><br><em> 不断重复发生的问题  
</em> 解决方案的核心<br><em> 重复使用<br><br>设计模式和面向对象设计是分不开的，我们还要着重理解面向对象：

</em> 向下，如何把握机器底层从微观理解对象构造<br>  <em> 语言构造  
  </em> 编译转换<br>  <em> 内存模型  
  </em> 运行时机制<br><br><em> 向上：如何将我们周围的世界抽象为程序代码  
  </em> 面向对象<br>  <em> 组件封装  
  </em> 设计模式<br>  <em> 架构模式<br><br><strong>深入理解面向对象：</strong> 

</em> 向下：三大面向对象机制<br>  <em> 封装，隐藏内部实现  
  </em> 继承，复用现有代码<br>  <em> 多态，改写对象行为    

</em> 向上：<br> <em> 深刻把握面向对象机制所带来的抽象意义,理解如何使用这些机制来表达现实世界，掌握什么是“好的面向对象设计”<br><br>—————-<br><br><h4 id="2">面向对象设计原则</h4><br><strong>变化是复用的天敌。</strong>而面向对象的优势就在于<strong>抵御变化</strong>。<br>为了抵御变化，我们要程序设计中使用合适的设计模式。<br><br><strong>重新认识面向对象：</strong><br>隔离变化：能将变化所带来的影响减到最小。<br>各司其职：面向对象的方式强调个各类的“职责”，新增加的类不会影响原有类。<br><strong>对象是什么？</strong><br>语言：对象封装了代码和数据。<br>规格：对象是一系列可被使用的公共接口。<br>概念：对象是某种拥有责任的抽象。<br><br><br>为什么要提倡“Design Pattern呢？根本原因是为了代码复用，增加可维护性。那么怎么才能实现代码复用呢？面向对象有几个原则：单一职责原则 （Single Responsiblity Principle SRP）开闭原则（Open Closed Principle，OCP）、里氏代换原则（Liskov Substitution Principle，LSP）、依赖倒置原则（Dependency Inversion Principle，DIP）、接口隔离原则（Interface Segregation Principle，ISP）、合成/聚合复用原则（Composite/Aggregate Reuse Principle，CARP）、最小知识原则（Principle of Least Knowledge，PLK，也叫迪米特法则）。开闭原则具有理想主义的色彩，它是面向对象设计的终极目标。其他几条，则可以看做是开闭原则的实现方法。<br>设计模式就是实现了这些原则，从而达到了代码复用、增加可维护性的目的。下面是这几个原则的一些简单介绍：<br><br><br>1. 依赖倒置原则（DIP）<br>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。<br><br>2. 开闭原则（OCP）<br>对拓展开放，对更改封闭。<br>在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。<br>因此，当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。<br><br>3. 单一职责原则（SRP）<br>类的职责要单一，不能将太多的职责放在一个类中。（高内聚、低耦合）<br>功能单一便于使用和维护，并且不会发生太多干扰。<br><br>4. Liskor替换原则（LSP）<br>子类必须能替换他的基类。<br><br>5. 接口隔离原则（ISP）<br>客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。<br><br>6. 优先使用对象组合，而不是类继承<br>继承为白箱复用，某种程度上为打破了封装性，耦合度高。<br>利用对象组合则拥有良好定义的接口，耦合度低。<br><br>7. 封装变化点<br>使用封装来创建对象间的分界层。让设计可以在分界层一侧进行修改，而不影响另一侧。实现层次间的松耦合。<br><br>8. 针对接口编程，而不是针对实现编程<br>不将变量类型设置为具体的类，而是声明为接口。这样客户无需知道对象的具体类型，而只需知道对象具有的接口，减少各部分的依赖关系，实现“高内聚，低耦合”的设计思想。<br><br><br><strong>重构获得模式 Refactoring to Patterns</strong>  

</em> 应对变化，提高复用<br><em> 发现变化，在变化点处应用设计模式。什么时候、什么地点应用设计模式比理解设计模式结构本身更为重要  
</em> 设计模式应用不宜先入为主。没有一步到位的设计模式。<br><br><strong>重构关键技巧(其实下面几点归根结底都是同一个本质)：</strong><br><br>静态 -&gt; 动态<br>早绑定 -&gt; 晚绑定<br>继承 -&gt; 组合<br>编译器依赖 -&gt; 运行时依赖<br>紧耦合 -&gt; 松耦合<br><br><br>—————-<br><br><h4 id="3">Template Method 模板方法模式</h4>    

<p>在软件构件过程中，对于某一项任务，它常常有稳定的整体操作结构，但是个个自步骤却有很多改变的需求，或者由于固有的原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现。<br>定义一个操作中的算法的<strong>骨架（稳定）</strong>，而将一些步骤<strong>延迟（变化）</strong>到子类中。Template Method使得子类可以<strong>不改变（复用）</strong>一个算法的结构即可<strong>重定义（override重写）</strong>该算法的某些特定步骤。</p>
<p><strong>要点总结：</strong>  </p>
<ul>
<li>Template Method模式是一种非常基础性的设计模式，在面向对象系统中有着大量的应用。使用虚函数的多态性为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本实现结构。  </li>
<li>除了可以灵活对子步骤的变化外，“不要调用我，让我来调用你”的反向控制结构是Template Method的典型应用。  </li>
<li>在实现时，被Template Method调用的虚方法可以具有实现，也可以没有任何实现（抽象方法、纯虚方法），但一般推荐将他们设置为protected方法。</li>
</ul>
<hr>
<h4 id="4">Strategy 策略模式</h4>  

<p>在软件构件过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常负责，而且有时候支持不适用的算法也是一个性能负担。<br>定义一系列算法，把他们一个个封装起来，并且使他们可以<strong>相互替换（变化）</strong>，该模式使得算法可独立于使用它的客户程序<strong>（稳定）而变化（扩展，子类化）</strong>。</p>
<p><strong>要点总结</strong>  </p>
<ul>
<li>Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换。</li>
<li>Strategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需要使用Strategy模式。</li>
<li>如果Strategy对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省对象开销。</li>
</ul>
<hr>
<h4 id="5">Observer/Event 观察者/事件模式</h4><br>在软件构建过程中，我们需要为某些对象建立一种<strong>“通知依赖关系”</strong> —— 一个对象（目标对象）的状态发生改变，所有的<strong>依赖对象（观察者对象）都将得到通知</strong>。<br>定义对象间的<strong>一种一对多（变化）的依赖关系</strong>，以便当一个对象（Subject）的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。<br><br><strong>要点总结</strong><br><br><em> 使用面向对象的抽象，Observer模式使得我们可以独立地改变（改变时，两者不相互影响）目标与观察者，从而使二者之间的依赖关系松耦合。
</em> 目标发送通知时，无需指定观察者，通知（可以携带通知信息作为参数）会自动传播。<br><em> 观察者自己决定是否需要订阅通知，目标对象对此一无所知。
</em> <strong>Observer模式是基于事件的UI框架中非常常用的设计模式，是MVC的一个重要组成部分。</strong><br><br><br>—————-<br><br><h4 id="6">Decorator 装饰模式</h4><br>在某些情况下，我们可能会“过度的使用继承来扩展对象的功能”，由于继承为类型引入的静态特性，使得这种扩展方式缺少灵活性，并且随着子类的增多，各种子类的组合会导致更多子类的膨胀。<br>动态（组合）的给一个对象增加一些额外的职责，就增加功能而言，Decorator模式比生成子类（继承）更为灵活（消除重复代码&amp;减少子类个数）。<br><br><strong>要点总结</strong><br><br><em> 通过组合而非继承的手法，Decorator模式实现了在运行时动态扩展对象功能的能力，可根据需要扩展多个功能。避免了使用继承带来的“灵活性差”和“多子类衍生问题”。
</em> Decorator类在接口上表现为is-a Component的继承关系，即Decorator类继承了Component类的所有接口。但是在实现上又表现为has-a Component的组合关系，即Decorator类又使用了另一个Component类。<br>* Decorator模式的目的并非解决“多子类衍生的多继承”问题，其要点在于解决“主体类在多个方向上的扩展功能”—-是为“装饰”的含义。<br><br>—————-<br><br><h4 id="7">Bridge 桥模式</h4>  

<p>由于某些类型的固有的实现逻辑，使得它们具有连个变化的维度，乃至多个维度的变化。<br>为了应对这种多维度的变化，我们需要利用面向对象技术来是的类型可以轻松地沿着两个乃至于多个方向变化，而不引入额外的复制维度。这时候我们就需要使用桥模式：</p>
<blockquote>
<p>将抽象部分（业务功能）与实现部分（平台实现）分离，使它们都可以独立的变化。<br>           –《设计模式》GoF</p>
</blockquote>
<p><strong>要点总结:</strong></p>
<ul>
<li>Bridge模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度变化（子类）。所谓抽象和实现沿着各自纬度的变化，即“子类化”它们。</li>
<li>Bridge模式有时候类似于多继承方案，但是多继承方案往往违背单一职责原则（即一个类只有一个变化的原因），复用性较差。Bridge模式是比多继承方案更好的解决方案。</li>
<li>Bridge模式的应用一般在“两个非常强的变化维度”，有时候一个类也有多于两个的变化纬度，这时可以使用Bridge的扩展模式。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/11/geekband-cshe-ji-mo-shi-part-1/" data-id="cjf6xd19y000739zp7ky85gw8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/07/18/geekband-cshe-ji-mo-shi-part-2/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          [GeekBand] C++设计模式 part.2
        
      </div>
    </a>
  
  
    <a href="/2016/07/04/geekband-stlyu-fan-xing-bian-cheng-shang-ke-bi-ji-part-3/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">[GeekBand] STL与泛型编程上课笔记 part.3</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/06/24/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2016/09/10/hackerrank-dijkstra-shortest-reach-2-ru-he-tong-guo-yi-xing-dai-ma-bi-mian-timeout/">[Hackerrank] Dijkstra: Shortest Reach 2 &amp; 如何通过一行代码避免TIMEOUT</a>
          </li>
        
          <li>
            <a href="/2016/08/19/ru-he-zai-cczhong-huo-qu-shu-zhi-de-zui-da-huo-zhe-zui-xiao-zhi/">如何在C++/C中获取数值的最大或者最小值</a>
          </li>
        
          <li>
            <a href="/2016/08/15/xi-tong-she-ji-yu-shi-jian-part-3/">系统设计与实践 part.3</a>
          </li>
        
          <li>
            <a href="/2016/08/07/xi-tong-she-ji-yu-shi-jian-part-2/">系统设计与实践 part.2</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Alex Tang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>