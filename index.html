<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="IndigoAxe">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="IndigoAxe">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="IndigoAxe">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>IndigoAxe</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">IndigoAxe</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/10/dijkstra-shortest-reach-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Tang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IndigoAxe">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/10/dijkstra-shortest-reach-2/" itemprop="url">Dijkstra: Shortest Reach 2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-10T11:48:46+08:00">
                2018-09-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天花了好长的时间解<br><a href="https://www.hackerrank.com/challenges/dijkstrashortreach" target="_blank" rel="noopener">这道题</a><br>的Case 7。 不管程序怎么优化，结果都是timeout。接着使用Mac自带的Instrument来分析，竟让发现是读取输入的时候最费时。实在摸不着头脑。<br>最后在discussion里面看到有人说可以通过<code>sync_with_stdio</code>来解决这一个问题。试了一下，结果还真通过了。亏我还放弃了剩下的分数去看别人的实现方式（然而他们的code也通不过case7还得了60分，令人费解= =），知道真相的我泪流满面。不过作为一个菜鸟，学到了一些新的东西还是很高兴的。<br>搜了一下<code>sync_with_stdio</code>，原来：</p>
<blockquote>
<p><a href="http://www.hankcs.com/program/cpp/cin-tie-with-sync_with_stdio-acceleration-input-and-output.html" target="_blank" rel="noopener">引用:</a></p>
</blockquote>
<blockquote>
<p>这个函数是一个“是否兼容stdio”的开关，C++为了兼容C，保证程序在使用了std::printf和std::cout的时候不发生混乱，将输出流绑到了一起。</p>
</blockquote>
<blockquote>
<p>在ACM里，经常出现数据集超大造成 cin TLE的情况。这时候大部分人（包括原来我也是）认为这是cin的效率不及scanf的错，甚至还上升到C语言和C++语言的执行效率层面的无聊争论。其实像上文所说，这只是C++为了兼容而采取的保守措施。我们可以在IO之前将stdio解除绑定，这样做了之后要注意不要同时混用cout和printf之类。<br>在默认的情况下cin绑定的是cout，每次执行 &lt;&lt; 操作符的时候都要调用flush，这样会增加IO负担。可以通过tie(0)（0表示NULL）来解除cin与cout的绑定，进一步加快执行效率。</p>
</blockquote>
<p>下面是我的实现，其中利用了stl的priority_queue优先级队列来实现，提高了效率:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef pair&lt; int, int &gt; pi;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // Unbind </span><br><span class="line">    std::ios::sync_with_stdio(false); </span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        int N,M;</span><br><span class="line">        cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">        map&lt;int ,int&gt; nodes[N+1];</span><br><span class="line">        // read the edges</span><br><span class="line">        for(int i=0;i&lt;M;++i)&#123;</span><br><span class="line">            int e1,e2,d;</span><br><span class="line">            cin &gt;&gt; e1 &gt;&gt; e2 &gt;&gt; d;</span><br><span class="line">            if(nodes[e1].count(e2)==0 || nodes[e1][e2]&gt;d)&#123;</span><br><span class="line">                nodes[e1][e2] = d;</span><br><span class="line">                nodes[e2][e1] = d;            </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int S;</span><br><span class="line">        cin &gt;&gt; S;</span><br><span class="line">        bool vis[N+1];</span><br><span class="line">        int dis[N+1];</span><br><span class="line">        memset(vis,false,sizeof(vis));</span><br><span class="line">        for(int i=0;i&lt;=N;++i)&#123;</span><br><span class="line">            dis[i]=100000;</span><br><span class="line">        &#125;</span><br><span class="line">        dis[S] = 0;</span><br><span class="line">        // Use min heap so that the min value can be popped earlier </span><br><span class="line">        priority_queue&lt;pi, vector&lt;pi&gt;, greater&lt;pi&gt; &gt; q;</span><br><span class="line">        q.push(pi(0,S));</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            int curr = q.top().second;</span><br><span class="line">            int curr_cost = q.top().first;</span><br><span class="line">            q.pop();</span><br><span class="line">            if(dis[curr]&lt;curr_cost) continue;</span><br><span class="line">            if(vis[curr]) continue;</span><br><span class="line">            vis[curr] = true;</span><br><span class="line">            for(auto &amp;m: nodes[curr])&#123;                </span><br><span class="line">                int fir = m.first;</span><br><span class="line">                int sec = m.second;   </span><br><span class="line">                if(!vis[fir] &amp;&amp; dis[curr] + sec &lt; dis[fir])&#123;</span><br><span class="line">                   dis[fir] = dis[curr]+sec; </span><br><span class="line">                   q.push(pi(dis[fir],fir));</span><br><span class="line">               &#125;      </span><br><span class="line">               </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=1;i&lt;=N;++i)&#123;</span><br><span class="line">            if(i!=S)&#123;</span><br><span class="line">                if(dis[i]==100000)</span><br><span class="line">                    cout &lt;&lt; &quot;-1 &quot;;</span><br><span class="line">                else</span><br><span class="line">                    cout &lt;&lt; dis[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">            &#125;                </span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/19/ru-he-zai-cczhong-huo-qu-shu-zhi-de-zui-da-huo-zhe-zui-xiao-zhi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Tang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IndigoAxe">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/19/ru-he-zai-cczhong-huo-qu-shu-zhi-de-zui-da-huo-zhe-zui-xiao-zhi/" itemprop="url">如何在C++/C中获取数值的最大或者最小值</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-19T05:55:12+08:00">
                2018-08-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在stackoverflow 看到这一<a href="http://stackoverflow.com/questions/1855459/maximum-value-of-int" target="_blank" rel="noopener">问题</a>。于是记录下来,顺便附上一些相关资料：<br>C++:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;limits&gt;</span><br><span class="line">then use</span><br><span class="line"></span><br><span class="line">int imin = std::numeric_limits&lt;int&gt;::min(); // minimum value</span><br><span class="line">int imax = std::numeric_limits&lt;int&gt;::max();</span><br><span class="line">std::numeric_limits is a template type which can be instantiated with other types:</span><br><span class="line"></span><br><span class="line">float fmin = std::numeric_limits&lt;float&gt;::min(); // minimum positive value</span><br><span class="line">float fmax = std::numeric_limits&lt;float&gt;::max();</span><br></pre></td></tr></table></figure>

<p>C:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;limits.h&gt;</span><br><span class="line">then use</span><br><span class="line"></span><br><span class="line">int imin = INT_MIN; // minimum value</span><br><span class="line">int imax = INT_MAX;</span><br></pre></td></tr></table></figure>

<p>or</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;float.h&gt;</span><br><span class="line"></span><br><span class="line">float fmin = FLT_MIN;  // minimum positive value</span><br><span class="line">double dmin = DBL_MIN; // minimum positive value</span><br><span class="line"></span><br><span class="line">float fmax = FLT_MAX;</span><br><span class="line">double dmax = DBL_MAX;</span><br></pre></td></tr></table></figure>

<hr>
<p>以下内容转自：<a href="http://www.cnblogs.com/zhaoyx/articles/2339898.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhaoyx/articles/2339898.html</a></p>
<table><tr><td>Type</td><td>Size</td><td>数值范围</td></tr><tr><td>无值型void</td><td>0 byte</td><td>无值域</td></tr><tr><td>布尔型bool    </td><td>1 byte</td><td>true   false</td></tr><tr><td>有符号短整型short [int] /signed short [int]</td><td>2 byte</td><td>-32768~32767</td></tr><tr><td>无符号短整型unsigned short [int]  </td><td>2 byte</td><td>0~65535</td></tr><tr><td>有符号整型int /signed [int]</td><td>4 byte</td><td>-2147483648~2147483647</td></tr><tr><td>无符号整型unsigned [int]</td><td>4 byte</td><td>0~4294967295</td></tr><tr><td>有符号长整型long [int]/signed long [int]</td><td>4 byte</td><td>-2147483648~2147483647</td></tr><tr><td>无符号长整型unsigned long [int]</td><td>4 byte</td><td>0~4294967295</td></tr><tr><td>long long</td><td>8 byte</td><td>0~18446744073709552000</td></tr><tr><td>有符号字符型char/signed char</td><td>1 byte</td><td>-128~127</td></tr><tr><td>无符号字符型unsigned char</td><td>1 byte</td><td>0~255</td></tr><tr><td>宽字符型wchar_t (unsigned short.)</td><td>2 byte</td><td>0~65535</td></tr><tr><td>单精度浮点型float </td><td>4 byte</td><td>-3.4E-38~3.4E+38</td></tr><tr><td>双精度浮点型double</td><td>8 byte</td><td>1.7E-308~1.7E+308</td></tr><tr><td>long double</td><td>8 byte</td><td></td></tr></table>

<p>说明：</p>
<p>（1）类型修饰符signed和unsigned用于修饰字符型和整形。</p>
<p>（2）类型修饰符short和long用于修饰字符型和整形。</p>
<p>（3）当用signed和unsigned、short和long修饰int整形时，int可省略。</p>
<p>（4）其中bool和wchar_t是C++特有的。</p>
<p>（5）除上表以外，C/C++都可以自定义枚举enum、联合union和struct结构体类型。</p>
<p>（6）以上sizeof通过Windows XP 32位平台测试，其中某些类型数据的字节数和数值范围由操作系统和编译平台决定。比如16位机上，sizeof(int) = 2，而32位机上sizeof(int) = 4；32位机上sizeof(long) = 4，而64位机上sizeof(long) = 8。除此之外，注意64位机上的pointer占8byte。</p>
<p>（7）void的字面意思是“无类型”，不能用来定义变量。void真正发挥的作用在于：&lt;1&gt; 对函数返回和函数参数的限定，例如自定义既不带参数也无返回值的函数void MyFunc(void);&lt;2&gt;定义无类型通用指针void *，指向任何类型的数据。</p>
<p>（8）标准C++库及STL还提供了通用数据结构：字符串类string；向量类模板vector；双端队列类模板deque；链表类模板list；容器适配器堆栈类stack（实现先进后出的操作）；容器适配器队列类queue（实现先进先出的操作）；集合类set；多重集合类multiset；映射类map；多重映射类multimap；位集合bitset；迭代器iterator (类似指针的功能,对容器的内容进行访问)。</p>
<p>（9）在标准c++中，int的定义长度要依靠你的机器的字长，也就是说，如果你的机器是32位的，int的长度为32位，如果你的机器是64位的，那么int的标准长度就是64位，而vc中__int64是为在32机位机器长实现64位长度的整形数。</p>
<p>（10）关于32位平台下的int和long</p>
<p>long从字面上看，应该是64位才更合理，把long当成32位实在是一个历史的包袱。像C#那样新起炉灶的程序语言，由于没有需要支持老代码的问题，就把long当作64位来处理了。</p>
<p>在32位平台下，long是相对short而言，long（short）类型是long（short） int类型的简称，sizeof(long) = sizeof(int) = 4。int和long的范围虽然一样,但输入输出格式不同,printf int的格式为%d，而printf long的格式为%ld。</p>
<p>考虑到程序的可移植性，还是要将他们区分开来。但当要求的数值范围为4byte时，建议使用int类型，因为第一版的C语言只有一种类型，那就是int。</p>
<p>（11）在Win32 API及MFC中为了使类型名称在语意上更明了，对以上基本类型进行了大量的typedef。例如WINDEF.H中的BYTE,WORD,DWORD。</p>
<p>（12）计算机内部内存的基本单位是1byte(8个电子开关)。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/15/xi-tong-she-ji-yu-shi-jian-part-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Tang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IndigoAxe">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/15/xi-tong-she-ji-yu-shi-jian-part-3/" itemprop="url">系统设计与实践 part.3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-15T15:08:42+08:00">
                2018-08-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3>海量数据处理方法主要有以下几种：</h3>

<ul>
<li><a href="#1">1.Hash</a></li>
<li><a href="#2">2.Bit-Map</a></li>
<li><a href="#3">3.Bloom Filter</a></li>
<li><a href="#4">4.堆(Heap)</a></li>
<li><a href="#5">5.双层桶划分</a></li>
<li><a href="#6">6.数据库索引</a></li>
<li><a href="#7">7.倒排索引（Inverted Index）</a></li>
<li><a href="#8">8.B+树</a></li>
<li><a href="#9">9.Trie树</a></li>
<li><a href="#10">10.MapReduce</a></li>
</ul>
<hr>
<h4 id="1">Hash</h4>

<p>Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p>
<p>HASH主要用于信息安全领域中加密算法，它把一些不同长度的信息转化成杂乱的128位的编码,这些编码值叫做HASH值. 也可以说，hash就是找到一种数据内容和数据存放地址之间的映射关系。</p>
<p>数组的特点是：寻址容易，插入和删除困难；而链表的特点是：寻址困难，插入和删除容易。那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表，哈希表有多种不同的实现方法，我接下来解释的是最常用的一种方法——拉链法，我们可以理解为“链表的数组”，如图：</p>
<p>左边很明显是个数组，数组的每个成员包括一个指针，指向一个链表的头，当然这个链表可能为空，也可能元素很多。我们根据元素的一些特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再从链表中找出这个元素。</p>
<p>元素特征转变为数组下标的方法就是散列法。散列法当然不止一种，下面列出三种比较常用的。</p>
<p>1，除法散列法<br>最直观的一种，上图使用的就是这种散列法，公式：<br>index = value % 16<br>学过汇编的都知道，求模数其实是通过一个除法运算得到的，所以叫“除法散列法”。</p>
<p>2，平方散列法<br>求index是非常频繁的操作，而乘法的运算要比除法来得省时（对现在的CPU来说，估计我们感觉不出来），所以我们考虑把除法换成乘法和一个位移操作。公式：<br>index = (value * value) &gt;&gt; 28<br>如果数值分配比较均匀的话这种方法能得到不错的结果，但我上面画的那个图的各个元素的值算出来的index都是0——非常失败。也许你还有个问题，value如果很大，value * value不会溢出吗？答案是会的，但我们这个乘法不关心溢出，因为我们根本不是为了获取相乘结果，而是为了获取index。</p>
<p>3，斐波那契（Fibonacci）散列法</p>
<p>平方散列法的缺点是显而易见的，所以我们能不能找出一个理想的乘数，而不是拿value本身当作乘数呢？答案是肯定的。</p>
<p>1，对于16位整数而言，这个乘数是40503<br>2，对于32位整数而言，这个乘数是2654435769<br>3，对于64位整数而言，这个乘数是11400714819323198485</p>
<p>这几个“理想乘数”是如何得出来的呢？这跟一个法则有关，叫黄金分割法则，而描述黄金分割法则的最经典表达式无疑就是著名的斐波那契数列，如果你还有兴趣，就到网上查找一下“斐波那契数列”等关键字，我数学水平有限，不知道怎么描述清楚为什么，另外斐波那契数列的值居然和太阳系八大行星的轨道半径的比例出奇吻合，很神奇，对么？</p>
<p>对我们常见的32位整数而言，公式：<br>i ndex = (value * 2654435769) &gt;&gt; 28</p>
<p>如果用这种斐波那契散列法的话，那我上面的图就变成这样了：</p>
<p>很明显，用斐波那契散列法调整之后要比原来的取摸散列法好很多。</p>
<p>【适用范围】</p>
<p>快速查找，删除的基本数据结构，通常需要总数据量可以放入内存。</p>
<p>【基本原理及要点】<br>hash函数选择，针对字符串，整数，排列，具体相应的hash方法。<br>碰撞处理，一种是open hashing，也称为拉链法；另一种就是closed hashing，也称开地址法，opened addressing。</p>
<p>【扩展】<br>d-left hashing中的d是多个的意思，我们先简化这个问题，看一看2-left hashing。2-left hashing指的是将一个哈希表分成长度相等的两半，分别叫做T1和T2，给T1和T2分别配备一个哈希函数，h1和h2。在存储一个新的key时，同 时用两个哈希函数进行计算，得出两个地址h1[key]和h2[key]。这时需要检查T1中的h1[key]位置和T2中的h2[key]位置，哪一个 位置已经存储的（有碰撞的）key比较多，然后将新key存储在负载少的位置。如果两边一样多，比如两个位置都为空或者都存储了一个key，就把新key 存储在左边的T1子表中，2-left也由此而来。在查找一个key时，必须进行两次hash，同时查找两个位置。</p>
<p>【问题实例】<br>1).海量日志数据，提取出某日访问百度次数最多的那个IP。</p>
<p>IP的数目还是有限的，最多2^32个，所以可以考虑使用hash将ip直接存入内存，然后进行统计。</p>
<hr>
<h4 id="2">Bit-map</h4>


<p>所谓的Bit-map就是用一个bit位来标记某个元素对应的Value， 而Key即是该元素。由于采用了Bit为单位来存储数据，因此在存储空间方面，可以大大节省。</p>
<p>如果说了这么多还没明白什么是Bit-map，那么我们来看一个具体的例子，假设我们要对0-7内的5个元素(4,7,2,5,3)排序（这里假设这些元素没有重复）。那么我们就可以采用Bit-map的方法来达到排序的目的。要表示8个数，我们就只需要8个Bit（1Bytes），首先我们开辟64Bytes的空间，将这些空间的所有Bit位都置为0(如下图：)</p>
<p>然后遍历这5个元素，首先第一个元素是4，那么就把4对应的位置为1（可以这样操作 p+(i/8)|(0x01&lt;&lt;(i%8)) 当然了这里的操作涉及到Big-ending和Little-ending的情况，这里默认为Big-ending）,因为是从零开始的，所以要把第五位置为一（如下图）：</p>
<p>然后再处理第二个元素7，将第八位置为1,，接着再处理第三个元素，一直到最后处理完所有的元素，将相应的位置为1，这时候的内存的Bit位的状态如下：</p>
<p>然后我们现在遍历一遍Bit区域，将该位是一的位的编号输出（2，3，4，5，7），这样就达到了排序的目的。</p>
<p>【适用范围】</p>
<p>可进行数据的快速查找，判重，删除，一般来说数据范围是int的10倍以下</p>
<p>【基本原理及要点】</p>
<p>使用bit数组来表示某些元素是否存在，比如8位电话号码</p>
<p>【扩展】</p>
<p>Bloom filter可以看做是对bit-map的扩展</p>
<p>【问题实例】</p>
<p>1)已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数。</p>
<p>8位最多99 999 999，大概需要99m个bit，大概10几m字节的内存即可。 （可以理解为从0-99 999 999的数字，每个数字对应一个Bit位，所以只需要99M个Bit==1.2MBytes，这样，就用了小小的1.2M左右的内存表示了所有的8位数的电话）</p>
<p>2)2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。</p>
<p>将bit-map扩展一下，用2bit表示一个数即可，0表示未出现，1表示出现一次，2表示出现2次及以上，在遍历这些数的时候，如果对应位置的值是0，则将其置为1；如果是1，将其置为2；如果是2，则保持不变。或者我们不用2bit来进行表示，我们用两个bit-map即可模拟实现这个2bit-map，都是一样的道理。</p>
<hr>
<h4 id="3"> Bloom Filter</h4>

<p>Bloom Filter是一种空间效率很高的随机数据结构，它利用位数组很简洁地表示一个集合，并能判断一个元素是否属于这个集合。Bloom Filter的这种高效是有一定代价的：在判断一个元素是否属于某个集合时，有可能会把不属于这个集合的元素误认为属于这个集合（false positive）。因此，Bloom Filter不适合那些“零错误”的应用场合。而在能容忍低错误率的应用场合下，Bloom Filter通过极少的错误换取了存储空间的极大节省。 这里有一篇关于Bloom Filter的详细介绍，不太懂的博友可以看看。</p>
<p>【适用范围】<br>可以用来实现数据字典，进行数据的判重，或者集合求交集</p>
<p>【基本原理及要点】<br>对于原理来说很简单，位数组+k个独立hash函数。将hash函数对应的值的位数组置1，查找时如果发现所有hash函数对应位都是1说明存在，很明显这 个过程并不保证查找的结果是100%正确的。同时也不支持删除一个已经插入的关键字，因为该关键字对应的位会牵动到其他的关键字。所以一个简单的改进就是 counting Bloom filter，用一个counter数组代替位数组，就可以支持删除了。<br>还有一个比较重要的问题，如 何根据输入元素个数n，确定位数组m的大小及hash函数个数。当hash函数个数k=(ln2)<em>(m/n)时错误率最小。在错误率不大于E的情况 下，m至少要等于n</em>lg(1/E)才能表示任意n个元素的集合。但m还应该更大些，因为还要保证bit数组里至少一半为0，则m应 该&gt;=nlg(1/E)<em>lge 大概就是nlg(1/E)1.44倍(lg表示以2为底的对数)。<br>举个例子我们假设错误率为0.01，则此时m应大概是n的13倍。这样k大概是8个。<br>注意这里m与n的单位不同，m是bit为单位，而n则是以元素个数为单位(准确的说是不同元素的个数)。通常单个元素的长度都是有很多bit的。所以使用bloom filter内存上通常都是节省的。<br>【扩展】<br>Bloom filter将集合中的元素映射到位数组中，用k（k为哈希函数个数）个映射位是否全1表示元素在不在这个集合中。Counting bloom filter（CBF）将位数组中的每一位扩展为一个counter，从而支持了元素的删除操作。Spectral Bloom Filter（SBF）将其与集合元素的出现次数关联。SBF采用counter中的最小值来近似表示元素的出现频率。<br>【问题实例】<br>给你A,B两个文件，各存放50亿条URL，每条URL占用64字节，内存限制是4G，让你找出A,B文件共同的URL。如果是三个乃至n个文件呢？<br>根据这个问题我们来计算下内存的占用，4G=2^32大概是40亿</em>8大概是340亿，n=50亿，如果按出错率0.01算需要的大概是650亿个bit。 现在可用的是340亿，相差并不多，这样可能会使出错率上升些。另外如果这些urlip是一一对应的，就可以转换成ip，则大大简单了。</p>
<hr>
<h4 id="4"> 堆(Heap)</h4>

<p>概念：堆是一种特殊的二叉树，具备以下两种性质<br>1）每个节点的值都大于（或者都小于，称为最小堆）其子节点的值<br>2）树是完全平衡的，并且最后一层的树叶都在最左边<br>这样就定义了一个最大堆。如下图用一个数组来表示堆：</p>
<p>那么下面介绍二叉堆：二叉堆是一种完全二叉树，其任意子树的左右节点（如果有的话）的键值一定比根节点大，上图其实就是一个二叉堆。</p>
<p>你一定发觉了，最小的一个元素就是数组第一个元素，那么二叉堆这种有序队列如何入队呢？看图：</p>
<p>假设要在这个二叉堆里入队一个单元，键值为2，那只需在数组末尾加入这个元素，然后尽可能把这个元素往上挪，直到挪不动，经过了这种复杂度为Ο(logn)的操作，二叉堆还是二叉堆。</p>
<p>那如何出队呢？也不难，看图：</p>
<p>出队一定是出数组的第一个元素，这么来第一个元素以前的位置就成了空位，我们需要把这个空位挪至叶子节点，然后把数组最后一个元素插入这个空位，把这个“空位”尽量往上挪。这种操作的复杂度也是Ο(logn)。</p>
<p>【适用范围】<br>海量数据前n大，并且n比较小，堆可以放入内存</p>
<p>【基本原理及要点】<br>最大堆求前n小，最小堆求前n大。方法，比如求前n小，我们比较当前元素与最大堆里的最大元素，如果它小于最大元素，则应该替换那个最大元 素。这样最后得到的n个元素就是最小的n个。适合大数据量，求前n小，n的大小比较小的情况，这样可以扫描一遍即可得到所有的前n元素，效率很高。</p>
<p>【扩展】<br>双堆，一个最大堆与一个最小堆结合，可以用来维护中位数。</p>
<p>【问题实例】<br>1)100w个数中找最大的前100个数。<br>用一个100个元素大小的最小堆即可</p>
<hr>
<h4 id="5"> 双层桶</h4>

<p>事实上，与其说双层桶划分是一种数据结构，不如说它是一种算法设计思想。面对一堆大量的数据我们无法处理的时候，我们可以将其分成一个个小的单元，然后根据一定的策略来处理这些小单元，从而达到目的。</p>
<p>【适用范围】<br>第k大，中位数，不重复或重复的数字</p>
<p>【基本原理及要点】<br>因为元素范围很大，不能利用直接寻址表，所以通过多次划分，逐步确定范围，然后最后在一个可以接受的范围内进行。可以通过多次缩小，双层只是一个例子，分治才是其根本（只是“只分不治”）。</p>
<p>【扩展】<br>当有时候需要用一个小范围的数据来构造一个大数据，也是可以利用这种思想，相比之下不同的，只是其中的逆过程。</p>
<p>【问题实例】<br>1).2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。</p>
<p>有 点像鸽巢原理，整数个数为2^32,也就是，我们可以将这2^32个数，划分为2^8个区域(比如用单个文件代表一个区域)，然后将数据分离到不同的区 域，然后不同的区域在利用bitmap就可以直接解决了。也就是说只要有足够的磁盘空间，就可以很方便的解决。 当然这个题也可以用我们前面讲过的BitMap方法解决，正所谓条条大道通罗马<del>~</del></p>
<p>2).5亿个int找它们的中位数。</p>
<p>这个例子比上面那个更明显。首先我们将int划分为2^16个区域，然后读取数据统计落到各个区域里的数的个数，之后我们根据统计结果就可以判断中位数落到那个区域，同时知道这个区域中的第几大数刚好是中位数。然后第二次扫描我们只统计落在这个区域中的那些数就可以了。</p>
<p>实 际上，如果不是int是int64，我们可以经过3次这样的划分即可降低到可以接受的程度。即可以先将int64分成2^24个区域，然后确定区域的第几 大数，在将该区域分成2^20个子区域，然后确定是子区域的第几大数，然后子区域里的数的个数只有2^20，就可以直接利用direct addr table进行统计了。</p>
<p>3).现在有一个0-30000的随机数生成器。请根据这个随机数生成器，设计一个抽奖范围是0-350000彩票中奖号码列表，其中要包含20000个中奖号码。</p>
<p>这个题刚好和上面两个思想相反，一个0到3万的随机数生成器要生成一个0到35万的随机数。那么我们完全可以将0-35万的区间分成35/3=12 个区 间，然后每个区间的长度都小于等于3万，这样我们就可以用题目给的随机数生成器来生成了，然后再加上该区间的基数。那么要每个区间生成多少个随机数呢？计 算公式就是：区间长度<em>随机数密度，在本题目中就是30000</em>（20000/350000）。最后要注意一点，该题目是有隐含条件的：彩票，这意味着你 生成的随机数里面不能有重复，这也是我为什么用双层桶划分思想的另外一个原因。</p>
<hr>
<h4 id="6"> 数据库索引</h4>

<p>索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。</p>
<p>　　数据库索引好比是一本书前面的目录，能加快数据库的查询速度。<br>　　例如这样一个查询：select * from table1 where id=44。如果没有索引，必须遍历整个表，直到ID等于44的这一行被找到为止；有了索引之后(必须是在ID这一列上建立的索引)，直接在索引里面找 44（也就是在ID这一列找），就可以得知这一行的位置，也就是找到了这一行。可见，索引是用来定位的。<br>　　索引分为聚簇索引和非聚簇索引两种，聚簇索引 是按照数据存放的物理位置为顺序的，而非聚簇索引就不一样了；聚簇索引能提高多行检索的速度，而非聚簇索引对于单行的检索很快。</p>
<p>　　建立索引的目的是加快对表中记录的查找或排序。<br>　　为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。</p>
<hr>
<h4 id="7"> 倒排索引</h4>


<p>倒排索引（inverted index）是一种索引方法，用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射，常用于搜索引擎和关键字查询等问题中。</p>
<p>以英文为例，下面是要被索引的文本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T0 = &quot;it is what it is&quot;  </span><br><span class="line">T1 = &quot;what is it&quot;  </span><br><span class="line">T2 = &quot;it is a banana&quot;</span><br></pre></td></tr></table></figure>

<p>我们就能得到下面的倒排索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;a&quot;:　　　&#123;2&#125;</span><br><span class="line">&quot;banana&quot;: &#123;2&#125;</span><br><span class="line">&quot;is&quot;:　　 &#123;0, 1, 2&#125;</span><br><span class="line">&quot;it&quot;:　　 &#123;0, 1, 2&#125;</span><br><span class="line">&quot;what&quot;:　 &#123;0, 1&#125;</span><br></pre></td></tr></table></figure>

<p>检索的条件”what”、”is”和”it”将对应集合的交集。</p>
<p>正向索引开发出来用于存储每个文档的单词的列表。正向索引的查询能够满足每个文档有序、频繁的全文查询和每个单词在校验文档中验证这样的查询。在正向索引中，文档占据了中心位置，每个文档指向了一个它所包含的索引项的序列，也就是说，文档指向了它包含的那些单词。而反向索引则是单词指向了包含它的文档，在倒排索引中，很容易看到这个反向的关系。</p>
<p>问题实例:<br>文档检索系统<br>请设计一个文档检索系统，用于查询哪些文件包含了某个单词，比如常见的学术论文的关键字搜索。</p>
<hr>
<h4 id="8"> B+树</h4>

<p>阅读参考：<a href="http://blog.csdn.net/quitepig/article/details/8041308" target="_blank" rel="noopener">B树、B-树、B+树、B*树 红黑树</a></p>
<hr>
<h4 id="9"> Trie树</h4>

<p>阅读参考：<a href="http://blog.csdn.net/quitepig/article/details/7869761" target="_blank" rel="noopener">海量数据处理之Tire树（字典树）</a></p>
<hr>
<h4 id="10"> MapReduce</h4>

<p>MapReduce是一种计算模型，简单地说就是将大批量的工作或数据分解执行（称之为Map），然后再将结果合并成最终结果（称之为Reduce）。这样做的好处是，可以在任务被分解后通过大量机器进行分布式并行计算，减少整个操作的时间。可以说，MapReduce的原理就是一个归并排序，它的适用范围为数据量大而数据种类少以致可以放入内存的场景。MapReduce模式的主要思想是将要执行的问题（如程序）自动拆分成Map和Reduce的方式。</p>
<p>在数据被分割后，通过Map函数将数据映射到不同的区块，分配给计算机集群处理，以达到分布式计算的效果，再通过Reduce函数的程序将结果汇总，从而输出需要的结果。</p>
<p>MapReduce 借鉴了函数式程序设计语言的设计思想，其软件实现是指定一个Map函数，把键值对映射成新的键值对，形成一系列中间结果构成的键值对，然后把它们传给 Reduce 函数，把具有相同中间形式的键值对合并在一起。Map 函数和Reduce函数具有一定的关联性。</p>
<p>问题实例<br>寻找n2个数的中数<br>一共有n台机器，每台机器上有n个数，每台机器最多存O(n)个数并对它们进行操作。如何找到n2个数的中数（median）？</p>
<p>以上主要内容转自：<a href="http://www.epubit.com.cn/article/290" target="_blank" rel="noopener">海量数据处理</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/07/xi-tong-she-ji-yu-shi-jian-part-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Tang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IndigoAxe">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/07/xi-tong-she-ji-yu-shi-jian-part-2/" itemprop="url">系统设计与实践 part.2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-07T09:04:03+08:00">
                2018-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="#1">1. 分布式系统</a><br>&nbsp; &nbsp; <a href="#1001">1.1 什么是分布式系统？</a><br>&nbsp; &nbsp; <a href="#1002">1.2 分布式系统特点</a><br>&nbsp; &nbsp; <a href="#1003">1.3 ACID vs. BASE</a><br><a href="#2">2. 数据库系统</a><br>&nbsp; &nbsp; <a href="#2001">2.1 设计原则:CAP理论</a><br>&nbsp; &nbsp; <a href="#2002">2.2 ACID vs. BASE</a><br>&nbsp; &nbsp; <a href="#2003">2.3 NoSQL数据库</a><br><a href="#3">3. 大数据系统</a><br>&nbsp; &nbsp; <a href="#3001">3.1 大数据基础: Hadoop</a><br>&nbsp; &nbsp; <a href="#3002">3.2 Google 大数据的三驾马车</a>  </p>
<hr>
<h4 id="1">1. 分布式系统</h4>

<h6 id="1001">1.1 什么是分布式系统？</h6>

<p>分布式系统是一大批服务器组成一个集合，对于用户来说这个集合仍然是一个整体连贯系统。<br>首先来看看三位大师对分布式系统的定义：   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A. Tanenbaum的定义：分布式网络的计算机中的组件之间协调动作通过消息进行通讯。    </span><br><span class="line">G. Coulouris的定义：当你知道有一台电脑崩溃，但是你的软件运行从来不会停止。</span><br><span class="line">Leslie Lamport的定义：分布式系统是这样系统：旨在支持应用程序和服务的开发，可以利用物理架构由多个自治的处理元素，不共享主内存，但通过网络发送异步消息合作。</span><br></pre></td></tr></table></figure>

<p>分布式系统与分层应用区别：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分层的应用程序（例如，3层）是划分应用程序逻辑，是一种逻辑分层，而不是物理，而分布式系统DS是物理分层，和实际部署有关。</span><br></pre></td></tr></table></figure>

<p>分布式系统与传统集中式系统相比：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">集中式系统是一种Scale out/in，纵向扩展，要么向上升级服务器到中大型机，要么升级多核，增加CPU核数，集中式纵向扩展适合计算聚合度比较高的数据，而分布式适合计算松散数据，非结构化或半结构化数据。无论采取哪种扩展伸缩方案，需要根据业务数据特点而定。</span><br><span class="line"></span><br><span class="line">任何分布式系统总是需要完成两个任务：计算和存储。计算和存储分离是分布式系统的重要特征。而通常在集中式或单机系统中，这两者是可能结合在一起，比如通过一个SQL语句实现查询后排序，查询是从存储中获得数据，排序是属于计算，因此这个SQL语句实际是将计算和存储耦合在一起。在应对大数据或大并发的情况下，这种方便的捆绑带来性能问题，而分布式计算和分布式存储虽然带来复杂性，但是也为系统的处理能力打开了上升拓展的空间。</span><br></pre></td></tr></table></figure>

<h6 id="1002">1.2 分布式系统特点</h6>

<p>并发性：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">共享资源，采取ACID或Base原则，见：CAP定理。</span><br><span class="line">分布式系统设计遵循CAP定理， CAP是：Consistency(一致性), Availability(可用性), 和 Partition tolerance(分区容错性) 可靠性 简称，CAP定理认为，CAP三种之中，只能同时满足其中两种。</span><br></pre></td></tr></table></figure>

<p>高可扩展性:   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是指系统能够在*运行过程中*自由地对系统内部节点或现有功能进行扩充，而*不影响*现有服务的运行。</span><br></pre></td></tr></table></figure>

<p>可靠性/可用性:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">故障发现和处理以及恢复容错处理。在一个正常运作系统中存在一个时间比例的条件。 如果一个用户不能访问系统比例增大，它被认为是不可用。可用性公式：</span><br><span class="line">Availability = uptime / (uptime + downtime)</span><br><span class="line">容错failover是指一个系统在错误发生的情况下，仍然一切运行正常。表示这个系统是宽容错误的。</span><br></pre></td></tr></table></figure>

<p>透明性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">访问透明度： 使用相同的操作本地和远程资源</span><br><span class="line">位置透明：访问资源无需知道其物理或网络位置</span><br><span class="line">并发透明度：多个进程可以同时运行访问使用共享资源，当不能干扰堵塞 它们的处理进程</span><br><span class="line">复制透明性： 资源的多个实例可以被用来复制以提高可靠性和性能，但无需由用户编制专门的应用程序来实现。</span><br><span class="line">故障透明度：出现软件硬件故障时，使用户和应用方案能继续完成他们的任务不受影响。</span><br><span class="line">移动透明度：允许在 系统存在移动的资源和客户。</span><br><span class="line">性能透明度：允许系统重新配置以 提高性能负荷变化</span><br><span class="line">缩放透明度：在应用程序结构没有变化的情况下能够在规模上扩展或伸缩系统，以提高吞吐量处理能力。</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2">2. 数据库系统</h4>

<h6 id="2001">2.1 设计原则:CAP理论</h6>
CAP理论是分布式数据库中很重要的理论基础。CAP即Consistnecy 一致性，Avaliability 可用性，Partition-tolerance分区容忍性 的缩写。在分布式系统中，三者不可兼得，只能得到其中之二。所以就有了三个分类：CA数据库，CP数据库，AP数据库。

<p>CA数据库不考虑分区容忍性，对应现实中是数据库就是普通的关系型数据库RDBMS，如MySQL, Oracle。<br>CP数据库考虑的是一致性和分区容忍性，这种数据库对分布式系统内的通信要求比较高，因为要保持数据的一致性，需要做大量的交互。目前常用的CP数据库：Bigtable，HBase。<br>AP数据库考虑的是实用性和分区容忍性，即外部访问数据，可以更快的得到回应。这时候，数据的一致性就可能得不到满足。比如一个数据，可能外部一个进程在改写这个数据，同时另一个进程在读这个数据，此时，数据显现是不一致的。但是有一点，就是数据库会满足一个最终一致性的概念，即过程可能是不一致的，但是到某一个终点，数据就会一致起来。比较出名的AP数据库：DynamoDB。</p>
<h6 id="2002">2.2 ACID vs. BASE</h6>
转自：[CAP原理和BASE思想](http://www.jdon.com/37625)  

<p>关系数据库的ACID模型拥有 高一致性 + 可用性 很难进行分区：<br>Atomicity原子性：一个事务中所有操作都必须全部完成，要么全部不完成。<br>Consistency一致性. 在事务开始或结束时，数据库应该在一致状态。<br>Isolation隔离性：事务将假定只有它自己在操作数据库，彼此不知晓。<br>Durability持久性：一旦事务完成，就不能返回。</p>
<p>==<strong>BASE思想</strong>==<br>主要强调基本的可用性，如果你需要高可用性，也就是纯粹的高性能，那么就要以一致性或容错性为牺牲，BASE思想的方案在性能上还是有潜力可挖的。</p>
<p>BASE模型反ACID模型，完全不同ACID模型，牺牲高一致性，获得可用性或可靠性：<br>Basically Available基本可用。支持分区失败(e.g. sharding碎片划分数据库)<br>Soft state软状态 状态可以有一段时间不同步，异步。<br>Eventually consistent最终一致，最终数据是一致的就可以了，而不是时时高一致。</p>
<p>BASE思想的主要实现有<br>1.按功能划分数据库<br>2.sharding碎片 </p>
<p>BASE思想主要强调基本的可用性，如果你需要High 可用性，也就是纯粹的高性能，那么就要以一致性或容错性为牺牲，BASE思想的方案在性能上还是有潜力可挖的。</p>
<p>现在NoSQL运动丰富了拓展了BASE思想，可按照具体情况定制特别方案，比如忽视一致性，获得高可用性等等，NOSQL应该有下面两个流派：</p>
<ol>
<li>Key-Value存储，如Amaze Dynamo等，可根据CAP三原则灵活选择不同倾向的数据库产品。</li>
<li>领域模型 + 分布式缓存 + 存储 （Qi4j和NoSQL运动），可根据CAP三原则结合自己项目定制灵活的分布式方案，难度高。</li>
</ol>
<p>这两者共同点：都是关系数据库SQL以外的可选方案，逻辑随着数据分布，任何模型都可以自己持久化，将数据处理和数据存储分离，将读和写分离，存储可以是异步或同步，取决于对一致性的要求程度。</p>
<p>不同点：NOSQL之类的Key-Value存储产品是和关系数据库头碰头的产品BOX，可以适合非Java如PHP RUBY等领域，是一种可以拿来就用的产品，而领域模型 + 分布式缓存 + 存储是一种复杂的架构解决方案，不是产品，但这种方式更灵活，更应该是架构师必须掌握的。</p>
<h6 id="2003">2.3 NoSQL数据库</h6>

<p>参考阅读:<a href="http://old.sebug.net/paper/databases/nosql/Nosql.html" target="_blank" rel="noopener">NoSQL数据库笔谈</a></p>
<hr>
<h4 id="3">3. 大数据系统</h4>

<h6 id="3001">3.1 大数据基础: Hadoop</h6>
==Hadoop核心==  
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hadoop的核心就是HDFS和MapReduce，而两者只是理论基础，不是具体可使用的高级应用，Hadoop旗下有很多经典子项目，比如HBase、Hive等，这些都是基于HDFS和MapReduce发展出来的。要想了解Hadoop，就必须知道HDFS和MapReduce是什么。</span><br></pre></td></tr></table></figure>

<p>==HDFS==<br>HDFS(Hadoop Distributed File System，Hadoop分布式文件系统)，它是一个高度容错性的系统，适合部署在廉价的机器上。HDFS能提供高吞吐量的数据访问，适合那些有着超大数据集(large data set)的应用程序。<br>HDFS的设计特点是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、大数据文件，非常适合上T级别的大文件或者一堆大数据文件的存储，如果文件只有几个G甚至更小就没啥意思了。</span><br><span class="line">2、文件分块存储，HDFS会将一个完整的大文件平均分块存储到不同计算器上，它的意义在于读取文件时可以同时从多个主机取不同区块的文件，多主机读取比单主机读取效率要高得多得都。</span><br><span class="line">3、流式数据访问，一次写入多次读写，这种模式跟传统文件不同，它不支持动态改变文件内容，而是要求让文件一次写入就不做变化，要变化也只能在文件末添加内容。</span><br><span class="line">4、廉价硬件，HDFS可以应用在普通PC机上，这种机制能够让给一些公司用几十台廉价的计算机就可以撑起一个大数据集群。</span><br><span class="line">5、硬件故障，HDFS认为所有计算机都可能会出问题，为了防止某个主机失效读取不到该主机的块文件，它将同一个文件块副本分配到其它某几个主机上，如果其中一台主机失效，可以迅速找另一块副本取文件。</span><br></pre></td></tr></table></figure>

<p>==HDFS的关键元素：==</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Block：将一个文件进行分块，通常是64M。</span><br><span class="line">NameNode：保存整个文件系统的目录信息、文件信息及分块信息，这是由唯一一台主机专门保存，当然这台主机如果出错，NameNode就失效了。在Hadoop2.*开始支持activity-standy模式----如果主NameNode失效，启动备用主机运行NameNode。</span><br><span class="line">DataNode：分布在廉价的计算机上，用于存储Block块文件。</span><br></pre></td></tr></table></figure>

<p>==MapReduce==<br>通俗说MapReduce是一套从海量·源数据提取分析元素最后返回结果集的编程模型，将文件分布式存储到硬盘是第一步，而从海量数据中提取分析我们需要的内容就是MapReduce做的事了。</p>
<p>参考阅读:<a href="http://tech.it168.com/a2011/1020/1261/000001261673_all.shtml" target="_blank" rel="noopener">深入浅出Hadoop： 高效处理大数据</a></p>
<h6 id="3002">3.2 Google 大数据的三驾马车</h6>
谈到分布式系统，就不得不提Google的三驾马车:  
GFS(Google File System)[1],Mapreduce[2],Bigtable[3]。
参考阅读：[分布式系统漫谈—— Google的三驾马车](http://storage.it168.com/a2011/0831/1240/000001240542.shtml)



<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/01/xi-tong-she-ji-yu-shi-jian-part-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Tang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IndigoAxe">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/01/xi-tong-she-ji-yu-shi-jian-part-1/" itemprop="url">系统设计与实践 part.1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-01T12:39:09+08:00">
                2018-08-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="#1">1. 了解系统设计</a><br><a href="#2">2. 系统设计面试</a><br><a href="#3">3. 系统设计中的七剑客</a></p>
<hr>
<h4 id="1">1. 了解系统设计</h4>

<p><strong>什么是系统设计(System Design)?</strong></p>
<p>System Design顾名思义，就是去设计一个system。通常来讲，设计一个万能的system是几乎不可能的，所以需要有具体的requirement， 根据requirement来tradeoff并决定使用某种架构。</p>
<p><strong>为什么要学习System Design?</strong></p>
<p>每个人学习System Design的动机不一样，但最常见的有两种原因:</p>
<p>你在准备面试，你的dream company会考到System Design；<br>你是架构师或者想成为架构师 需要用到相关知识。<br>我的观点是，即使是第一种情况，也希望你能抽出不少于刷leetcode的时间来看System Design。因为System Design和刷题的本质区别是，进入公司以后，除非你每天还在刷题保持状态，否则你早晚是要都还给老师的。而System Design才是你能长期收益的 一石二鸟，何乐而不为呢？</p>
<p><strong>学习System Design应该学习哪几块?</strong></p>
<p>我个人的经验，需要学习三大块:</p>
<p>Distributed System知识: 比如Sharding, Sticky sessions, etc。<br>架构知识: 有哪些架构是常用的？举个例子，Apache Storm的创始人Nathan Marz提出的Lambda Architecture就是一种典型的data processing架构 了解这些架构会对你搭建大型系统有很大帮助。<br>“积木”知识: 我管它叫积木，其实就是别人做好的轮子，拿来即用即可。但你需要了解该轮子的优缺点以及适用范围，比如SQS和kinesis的区别 ActiveMQ和Kafka的区别。</p>
<p><strong>面试和实践需要学习的点一样么?</strong><br>Yes and no.<br>Yes的原因是两大块对于面试和实践都是非常有帮助的；<br>No的原因是对于面试而言，面试官的侧重点是Distributed System的知识。知道某些积木会有加分但不是必须。而对于实践而言，知道各种积木以及其优缺点反而更能发挥作用。</p>
<p>以上内容引用自：<br>《System Design 101》<br><a href="https://zhuanlan.zhihu.com/p/21313382" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/21313382</a><br>作者：Joseph Holy</p>
<hr>
<h4 id="2">2. System Design面试</h4>

<p><strong>在系统设计的面试中，一般是这么打分的：</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bad      No sense of requirement, no scoping</span><br><span class="line">Pool     Limited knowledge, common sense</span><br><span class="line">Good     Reasonable Solution, explain clearly</span><br><span class="line">Great    Out of expectation, well thoughtful, tradeoff</span><br></pre></td></tr></table></figure>

<p><strong>最常见的题目有以下几个：</strong>  </p>
<ol>
<li>Tiny Url </li>
<li>RateLimit </li>
<li>Messenger / Chatroom </li>
<li>Stats Server </li>
<li>News Feed </li>
<li>Web Crawler </li>
<li>Location Based Service </li>
<li>Web Application </li>
<li>Word Count</li>
</ol>
<p><strong>我们拿最有代表性的Tiny Url来进行学习：</strong><br>题目 - Design a system to take user-provided URLs and transform them<br>to a shortened URLs that redirect back to original</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/23/pattern-part3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Tang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IndigoAxe">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/23/pattern-part3/" itemprop="url">C++设计模式 part.3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-23T08:21:08+08:00">
                2018-07-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="#1">1.Singleton 单件模式</a><br><a href="#2">2. Flyweight 享元模式</a><br><a href="#3">3. State 状态模式</a><br><a href="#4">4. Memento 备忘录</a><br><a href="#5">5. Composite 组合模式</a><br><a href="#6">6. Iterator 迭代器</a><br><a href="#7">7. Chain Of Resposibility 职责链</a><br><a href="#8">8. Command 命令模式</a><br><a href="#9">9. Vistor 访问者</a><br><a href="#10">10. Interpreter分析器</a>  </p>
<hr>
<p>对象性能类设计模式：  </p>
<p>面向对象很好地解决了“抽象”的问题，但是必不可免地要付出一定的代价。对于通常情况来讲，面向对象的成本大都可以忽略不计。但是某些情况，面向对象所带来的成本必须谨慎处理。<br>该类的典型模式 1) Singleton 2) Flyweight  </p>
<hr>
<h4 id="1">Singleton 单件模式</h4>

<p>==<strong>定义</strong>==<br>保证一个类只有一个实例，并提供一个该实例的全局访问点。</p>
<p>==<strong>动机</strong>==<br>在系统中，经常有这些一些特殊的类，必须保证它们在系统中只存在一个实例，才能确保它们的逻辑正确性、以及良好的效率。<br>如何绕过常规的构造器，保证一个类只有一个实例。<br>这应该是类设计者的责任，而不是使用者的责任。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//常规写法，线程不安全</span><br><span class="line">  Singleton* Singleton::getInstance()&#123;</span><br><span class="line">      if(m_instance == nullptr)&#123;</span><br><span class="line">          m_instance = new Singleton;</span><br><span class="line">      &#125;</span><br><span class="line">      return m_instance;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//加锁，但是代价太大</span><br><span class="line">  Singleton* Singleton::getInstance()&#123;</span><br><span class="line">      Lock lock;</span><br><span class="line">      if(m_instance == nullptr)&#123;</span><br><span class="line">          m_instance = new Singleton;</span><br><span class="line">      &#125;</span><br><span class="line">      return m_instance;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//双检查锁，但由于内存读写reorder不安全</span><br><span class="line">  Singleton* Singleton::getInstance()&#123;</span><br><span class="line">      if(m_instance == nullptr)&#123;</span><br><span class="line">          Lock lock;</span><br><span class="line">          if(m_instance == nullptr)&#123;</span><br><span class="line">              m_instance = new Singleton;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return m_instance;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>C++ 11 版本之后的跨平台实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;Singleton*&gt; Singleton::m_instance;</span><br><span class="line">std::mutex Singleton::m_mutex;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::getInstance()&#123;</span><br><span class="line">    Singleton* tmp = m_instance.load(std::memory_order_relaxed);</span><br><span class="line">    std::atomic_thread_fence(std::memory_order_acquire); //获取内存fence</span><br><span class="line">    if(tmp == nullptr)&#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(m_mutex);</span><br><span class="line">        if(tmp == nullptr)&#123;</span><br><span class="line">            tmp = new Singleton;</span><br><span class="line">            m_instance = new Singleton();</span><br><span class="line">            std::atomic_thread_fence(std::memory_order_release); //释放内存fence</span><br><span class="line">            m_instance.store(tmp, std::memory_order_relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>==<strong>要点总结</strong>== </p>
<ul>
<li>Singleton模式中的实例构造器可以设置为protected以允许子类派生。</li>
<li>Singleton模式一般不要支持拷贝构造函数和Clone接口，这会导致多个对象，违背了* Singleton模式的初衷。</li>
<li>多线程安全的Singleton，应该注意双检查锁的正确实现。</li>
</ul>
<hr>
<h4 id="2">Flyweight 享元模式</h4>

<p>==<strong>定义</strong>==<br>运用共享技术（解决效率问题的常用手段）有效地支持大量细粒度的对象。</p>
<p>==<strong>动机</strong>==<br>在软件系统采用纯粹对象方案的问题在于大量细粒度的对象会很快充斥在系统中，从而带来很高的运行时代价————主要指内存需求方面的代价。<br>如何在避免大量细粒度对象问题的同时，让外部客户程序仍然能够透明地使用面向对象的方式来进行操作？</p>
<p>==<strong>要点总结</strong>==  </p>
<ul>
<li>面向对象很好地解决了抽象性的问题，但是作为一个运行在机器中的程序实体，我们需要考虑对象的代价问题。Flyweight主要用来解决代价问题，一般不触及面向对象的抽象性问题。</li>
<li>Flyweight采用对象共享的做法来降低系统中对象的个数，从而降低细粒度对象给系统带来的内存压力。在具体实现方面，要注意对象状态的处理。</li>
<li>对象数量太大从而导致对象内存开销加大————什么样的数量才算大？这需要我们根据具体的应用情况去评估。</li>
</ul>
<hr>
<p><strong>状态变化类模式</strong><br>在组建构建过程中，某些对象的状态经常面临变化，如何对这些变化进行有效的管理？同时又维持高层模块的稳定？ 状态变化模式为这一问题提供了一种解决方案。<br>典型模式 1) State 2) Memento</p>
<hr>
<h4 id="3">State 状态模式</h4>

<p>==<strong>定义</strong>==<br>允许一个对象在内部状态改变时改变它的行为，从而使对象看起来似乎修改了其行为。<br>结构</p>
<p>==<strong>动机</strong>==<br>在软件构建过程中，某些对象的状态如果改变，其行为也会随之而发生改变，比如文档处于只读状态，其支持的行为和读写状态支持的行为就可能完全不同。<br>模式定义</p>
<p>==<strong>要点总结</strong>==    </p>
<ul>
<li>State模式将所有与一个特定状态相关的行为都放入一个State的子类对象中，在对象状态切换时、切换相应的对象；但同时维持State的接口，这样实现了具体操作与状态装换之间的解耦。</li>
<li>为不同的状态引入不同的对象使得状态转换变得更加明确，而且可以保证不会出现状态不一致的情况，因为转换时原子性的—-即要么彻底转换过来，要么不转换。</li>
<li>如果Stat对象没有实例变量，那么各个上下文可以共享同一个State对象，从容节省对象开销。</li>
</ul>
<hr>
<h4 id="4">Memento 备忘录</h4>

<p>==<strong>定义</strong>==<br>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态。</p>
<p>==<strong>动机</strong>==<br>在软件构建过程中，某些对象的状态在转换过程中，可能由于某种需要，要求程序能够回溯到对象之前处于某个点时的状态。如果使用一些共有接口来让其他对象得到对象的状态，便会暴露对象的实现细节。</p>
<p>==<strong>要点总结</strong>==</p>
<ul>
<li>备忘录（Memento）存储原发器（Originator）对象的内部状态，在需要时恢复原发器状态。</li>
<li>Memento模式的核心是信息隐藏，即Originator需要向外接隐藏信息，保持其封装性。但同时又需要将状态保持到外界（Memento）。</li>
<li>由于现代语言运行时（如C#、Java等）都具有相当的对象序列化支持，因此往往采用效率高、又容易正确实现的序列化方案来实现Memento模式。</li>
</ul>
<hr>
<p><strong>数据结构</strong><br>常常有一些组件在内部具有特定的数据结构，如果让客户程序依赖这些特定的数据结构，将极大的破坏组件的复用。这时候，将这些特定数据结构封装在内部，在外部提供统一的接口，来实现与特定数据结构无关的访问。<br>典型模式  </p>
<ul>
<li>Composite</li>
<li>Iterator</li>
<li>Chain Of Resposibility</li>
</ul>
<hr>
<h4 id="5">Composite 组合模式</h4>

<p>==<strong>定义</strong>==<br>将对象组合成树形结构以表示部分-整体的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性（稳定）。</p>
<p>==<strong>动机</strong>==<br>客户代码过多地依赖于对象容器复杂的内部实现结构，对象容器内部实现结构（而非抽象接口）的变化将引起客户代码的频繁变化，带来了代码的维护性、扩展性等弊端。<br>模式定义</p>
<p>==<strong>要点总结</strong>==</p>
<ul>
<li>Composite模式采用树形结构来实现普遍存在的对象容器，从而将一对多的关系转换成一对一的关系，使得客户程序可以一致地处理对象和对象容器，无需关心处理的是单个的对象，还是组合的对象容器。</li>
<li>将客户代码与复杂的对象容器结构解耦是Composite的核心思想，解耦之后，客户代码将与纯粹的抽象接口—-而非对象容器的内部实现结构—-发生依赖，从而更能应对变化。</li>
<li>Composite模式在具体实现中，可以让父对象中的子对象反向追溯；如果父对象有频繁的遍历要求，可使用缓存技巧来改善效率。</li>
</ul>
<h4 id="6">Iterator 迭代器</h4>

<p>==<strong>定义</strong>==<br>提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露（隔离变化，稳定）该对象的内部表示。</p>
<p>==<strong>动机</strong>==<br>集合对象内部结构常常变化各异。但对于这些集合对象，我们希望在不暴露其内部结构的同事，可以让外部客户代码透明地访问其中包含的元素。同时这种透明遍历也为同一种算法在多种集合对象上进行操作提供了可能。</p>
<p>==<strong>要点总结</strong>==  </p>
<ul>
<li>迭代抽象：访问一个聚合对象的内容而无需暴露它的内部表示。</li>
<li>迭代多态：为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。</li>
<li>迭代器的健壮性考虑：遍历的同时更改迭代器所在的集合结构，会导致问题。</li>
</ul>
<hr>
<h4 id="7">Chain Of Resposibility 职责链</h4>
==**定义**==  
使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。

<p>==<strong>动机</strong>==<br>一个请求可能被多个对象处理，但是每个请求在运行时只能有一个接受者，如果显示指定，将必不可少地带来请求发送者与接受者的紧耦合。</p>
<p>==<strong>要点总结</strong>==</p>
<ul>
<li>Chain Of Responsibility 模式的应用场合在于一个请求可能有多个接受者，但是最后真正的接受者只有一个，这个时候请求发送者与接受者的耦合有可能出现变化脆弱的症状，职责链的目的就是讲二者解耦，从而更好地应对变化。</li>
<li>应用了Chain Of Responsibility模式后，对象的责任分派将更具灵活定，我们可以在运行时添加/修改请求的处理职责。</li>
<li>如果请求传递到职责链的末尾扔得不到处理，应该有一个合理的缺省机制，这也是每一个接受对象的责任，而不是发出请求的对象的责任。</li>
</ul>
<hr>
<p><strong>行为变化</strong><br>在组件的构建过程中，组件行为的变化经常导致组件本身剧烈的变化，行为变化模式将组件的行为和组件本身进行解耦，从而支持组件的行为变化，实现两者之间的松耦合。<br>典型模式 1)Command 2)Visitor</p>
<hr>
<h4 id="8">Command 命令模式</h4>

<p>==<strong>定义</strong>==<br>将一个请求（行为）封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。</p>
<p>==<strong>动机</strong>==<br>行为请求者与行为实现者通常呈现一种紧耦合。但在某些场合—-比如需要对行为进行记录、撤销/重做、事务等处理，这种无法抵御变化的紧耦合使不合适的。</p>
<p>==<strong>要点总结</strong>==  </p>
<ul>
<li>Command模式的根本弟弟在于将行为请求者与行为实现者解耦，在面向对象语言中，常见的手段是将行为抽象为对象。</li>
<li>实现Command接口的具体命令对象ConcreteCommand有时候根据需要可能会保存一些额外的信息。通过使用Composite模式，可以讲多个命令封装为一个符合命令MacroCommand。</li>
<li>Command模式与C++中的函数对象有些类似，但两者定义行为接口的规范有所区别：* Command以面向对象中的接口–实现来定义行为接口说明，更严格，但有性能损失；C++函数对象以函数名来定义行为接口规范，更灵活，性能更高。</li>
</ul>
<hr>
<h4 id="9">Vistor 访问者</h4>

<p>==<strong>定义</strong>==<br>表示一个作用于某种对象结构中的各元素的操作。使得可以在不改变（稳定）各元素的类的前提下定义（扩展）作用于这些元素的新操作（变化）。</p>
<p>==<strong>动机</strong>==<br>在软件构建过程中，由于需求的改变，某些类层次结构中常常需要增加新的行为（方法），如果直接在积累中做这样的改变，将会给予子类带来很繁重的变更负担，甚至破坏原有设计。</p>
<p>==<strong>要点总结</strong>==</p>
<ul>
<li>Visitor模式通过所谓的双重分发（double dispatch）来实现在不更改（不添加新的操作–编译时）Element类层次结构的前提下，在运行时透明地为类层次结构上的各个类动态添加新的操作（支持变化）。</li>
<li>所谓双重分发即Visitor模式中间包括了两个多态分发（注意其中的多态机制）：第一个为accept方法的多态解析；第二个为visitElementX方法的多态辨析。</li>
<li>Visitor模式的最大缺点在于扩展类层次结构（添加新的Element子类），会导致Visitor类的改变。因此Visitor模式适用于Element类层次结构稳定，而其中的操作却经常面临频繁改动。</li>
</ul>
<hr>
<p><strong>领域规则</strong><br>在特定领域中，某些变化虽然频繁，但可以抽象为某种规则。这时候，结合特定领域，将问题抽象为语法规则，从而给出在该领域下的一般性解决方案。<br>典型模式: Interpreter</p>
<hr>
<h4 id="10">Interpreter 分析器</h4>

<p>==<strong>定义</strong>==<br>给定一个语言，定义它的文法的一种表示，并定义一种解释器，这个监视器使用该表示来解释语言中的句子。</p>
<p>==<strong>动机</strong>==<br>在软件构建过程中，如果某一特定领域的问题比较复杂，类似的结构不断重复出现，如果使用普通的编程方式来实现将面临非常频繁的变化。</p>
<p>==<strong>要点总结</strong>==  </p>
<ul>
<li>Interpreter模式的应用场合是Interprete模式应用中的难点，只有满足业务规则频繁变化，且类似的结构不断重复出现，并且容易抽象为语法规则的问题，才适合使用Interpreter模式。</li>
<li>使用Interpreter模式来表示文法规则，从而可以使用面向对象技巧来方便地扩展文法。</li>
<li>Interpreter模式比较适合简单的文法表示，对于复杂的文发表示，Interpreter模式会产生比较大的类层次结构，需要求助于语法分析生成器这样的标准工具。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/18/cshe-ji-mo-shi-part-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Tang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IndigoAxe">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/18/cshe-ji-mo-shi-part-2/" itemprop="url">C++设计模式 part.2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-18T15:07:40+08:00">
                2018-07-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="#1">1. Factory Method 工厂模式</a><br><a href="#2">2. Abstract Factory 抽象工厂</a><br><a href="#3">3. Prototype 原型模式</a><br><a href="#4">4. Builder 构建器</a><br><a href="#5">5. Facade 门面模式</a><br><a href="#6">6. Proxy 代理模式</a><br><a href="#7">7. Adapter 适配器模式</a><br><a href="#7">8. Meidator 中介者模式</a>  </p>
<p>本周主要讲了两个大类的设计模式：<strong>创建对象模式</strong>和<strong>接口隔离模式</strong>。首先我们先来理解一下这两个大类，然后再一个一个的去了解。</p>
<p>在创建对象模式中，我们将对象的创建和使用分离，使得系统更加符合“单一职责原则”，有利于对功能的复用和系统的维护。我们将对象的创建和使用分离还有一个好处：防止用来实例化一个类的数据和代码在多个类中到处都是，可以将有关创建的知识搬移到一个工厂类中，这在Joshua Kerievsky的《重构与模式》一书中有专门的一节来进行介绍。因为有时候我们创建一个对象不只是简单调用其构造函数，还需要设置一些参数，可能还需要配置环境，如果将这些代码散落在每一个创建对象的客户类中，势必会出现代码重复、创建蔓延的问题，而这些客户类其实无须承担对象的创建工作，它们只需使用已创建好的对象就可以了。此时，可以引入工厂类来封装对象的创建逻辑和客户代码的实例化/配置选项。</p>
<p>而符合接口隔离原则的模式和符合单一职责原则的模式又有什么区别呢？</p>
<p>首先我们要理解隔离原则的要求：建立单一接口，不要建立臃肿庞大的接口。再通俗的一点讲：接口尽量细化，同时接口中的方法尽量的少。看到这里大家有可能要疑惑了，这与单一职责原则不是相同的吗？错，接口隔离原则与单一职责的定义的规则是不相同的，单一职责要求的是类和接口职责单一，注重的是职责，没有要求接口的方法减少，例如一个职责可能包含10个方法，这10个方法都放在一个接口中，并且提供给多个模块访问，各个模块按照规定的权限来访问，在系统外通过文档约束不使用的方法不要访问，按照单一职责原则是允许的，按照接口隔离原则是不允许的，因为它要求“尽量使用多个专门的接口”,专门的接口指什么？就是指提供给多个模块的接口，提供给几个模块就应该有几个接口，而不是建立一个庞大的臃肿的接口，所有的模块可以来访问。<br>单一职责原则是从业务角度上来对类进行接口的抽象和细分，而接口隔离原则是从代码角度来对接口进行细分。因为单一职责原则得到的接口可能比较庞大，这就需要我们进行接口隔离原则的实施了。</p>
<p>引用：<br>[1] <a href="http://blog.csdn.net/nokianasty/article/details/11762379" target="_blank" rel="noopener">http://blog.csdn.net/nokianasty/article/details/11762379</a><br>[2] <a href="http://blog.csdn.net/lovelion/article/details/7523392/" target="_blank" rel="noopener">http://blog.csdn.net/lovelion/article/details/7523392/</a></p>
<hr>
<h4 id="1">Factory Method 工厂模式</h4>    


<p><strong>对象创建</strong>模式<br>通过“对象创建”模式绕开new，来避免对象创建(new)过程中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定，他是接口抽象之后的第一步工作。</p>
<p><strong>典型创建对象模式</strong></p>
<ul>
<li>Factory Method</li>
<li>Abstract Factory</li>
<li>Prototype</li>
<li>Builder</li>
</ul>
<p>==<strong>Factory Method模式定义：</strong>==</p>
<blockquote>
<p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使得一个类的实例化延迟（目的：解耦，手段：虚函数）到子类<br>《设计模式》GoF</p>
</blockquote>
<p>==<strong>动机</strong>==</p>
<p>在软件系统中，经常面临创建对象的工作，由于需求的变化，需要创建的对象的具体类型经常变化。</p>
<p>定义一个创建对象的接口，让子类决定实例化哪一个类。Factory Method使得一个类的实例化延迟（目的：解耦，手段：虚函数）。</p>
<p>==<strong>要点总结</strong>==  </p>
<ul>
<li>Factory Method模式用于隔离类对对象的使用者和具体类型之间的耦合关系。面对经常变化的具体类型，紧耦合关系（new）会导致软件的脆弱。</li>
<li>Factory Method模式通过面向对象的手法，将所要创建的具体对象工作延迟到子类，从而实现一种扩展（而非更改）的策略，较好的解决了紧耦合关系。</li>
<li>Factory Method模式解决“单个对象”的需求变化。缺点在于要求创建方法/参数相同。</li>
</ul>
<hr>
<h4 id="2">Abstract Factory 抽象工厂</h4>

<p>==<strong>动机</strong>==</p>
<p>在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作，同时，由于需求的变化，往往存在更多系列对象的创建工作。</p>
<p>提供一个借口，让该接口负责创建一系列“现骨干或者相互依赖的对象”，无需指定他们具体的类。</p>
<p>==<strong>要点总结</strong>==</p>
<ul>
<li>如果没有应对“多系列对象构建”的需求变化，则使用Factory Method就足够了。</li>
<li>“系列对象”指的是在某一特定系列下的对象之间有相互依赖或作用的关系。不同系列的对象之间不能相互依赖。</li>
<li>Abstract Factory模式主要在于应对“新系列”的需求变动（可以扩展一个系列），其缺点在于难以应对“新对象”的需求变动（某个已有系列需要增加新的对象）。</li>
<li>设计模式主要解决稳定中有变化的情况，如果在两个极端情况，一是所有地方都有变化，二是所有地方都不变化，那么就根本没有必要使用设计模式了。</li>
</ul>
<p><strong>综上所看，可以说Factory Method是Abstract Factory的一个特例，所以可以统称为Factory模式。</strong></p>
<hr>
<h4 id="3">Prototype 原型模式</h4>

<p>==<strong>动机</strong>==</p>
<p>在软件系统中，经常面临着“某些结构复杂的对象”的创建工作；由于需求的变化，这些对象经常面临着剧烈的变化，但是他们却拥有比较稳定一致的接口。</p>
<p>使用原型实例制定创建对象的种类，然后通过拷贝（深克隆）这些原型来创建新的对象。</p>
<p>和工厂模式不同，它主要能够解决工厂模式要求创建方法/参数相同的问题，尤其适应“某些结构复杂的对象”的创建工作。</p>
<p>==<strong>要点总结</strong>==</p>
<ul>
<li>Prototype模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合。同样要求这些“易变类”拥有“稳定的接口”。</li>
<li>Prototype模式对于“如何创建易变类的实体对象”曹勇“原型克隆”的方法来做，它使得我们可以非常灵活得动态创建“某些稳定接口”的新对象————所需工作仅仅是注册一个新类的对象，然后在任何需要的地方Clone。</li>
<li>Prototype模式中的Clone方法可以利用某些框架中的序列化来实现深拷贝（C++使用拷贝构造函数即可）。</li>
</ul>
<hr>
<h4 id="4">Builder 构建器</h4>

<p>==<strong>动机</strong>==</p>
<p>在软件系统中，经常面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个负责对象的各个部分经常面临着剧烈的变化，但是将他们组合在一起的算法却相对稳定。</p>
<p>将一个复杂对象的构建与其表示相分离，使得同样的构建过程（稳定）可以创建不同的表示（变化）。</p>
<p>==<strong>要点总结</strong>==</p>
<ul>
<li>Builder模式主要用于“分步骤构建一个负责的对象”。在这其中，“分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化。</li>
<li>变化点在哪里，封装到哪里————Builder模式主要在于对应“复杂对象各个部分”的频繁需求变动。缺点在于难以应对“分步骤构建算法”的需求变动。</li>
<li>在Builder模式中，要注意不同语言中构造器内调用虚函数的差别。</li>
</ul>
<hr>
<h4 id="5">Facade 门面模式</h4>

<p><strong>接口隔离模式</strong></p>
<p>在组件构建过程中，某些接口之间直接的依赖常常会带来很多问题、甚至根本无法实现。采用添加一层间接（稳定）接口，来隔离本来互相紧密关联的接口。</p>
<p>典型接口隔离模式</p>
<ul>
<li>Facade</li>
<li>Proxy</li>
<li>Adapter</li>
<li>Mediator</li>
</ul>
<p>==<strong>动机</strong>==</p>
<p>一些系统的问题在于组件的客户和组件中各种复杂的子系统有了过多的耦合，随着外部客户程序和各子系统的演化（变化），这种过多的耦合面临很多变化的挑战。</p>
<p>为子系统中的一组接口提供一个一致（稳定）的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用（复用）。</p>
<p>更多的体现的是一种设计原则和思想。关键在于子系统内外部的解耦。</p>
<p>==<strong>要点总结</strong>==</p>
<ul>
<li>从客户程序的角度来看，Facade模式简化了整个组件系统的接口，对于组件内部与外部客户程序来说，达到了“解耦”的效果————子系统内部的任何变化不会影响到Facade接口的变化。</li>
<li>Facade设计模式更注重从架构的层次去看整个系统，而不是单个类的层次。Facade很多时候更是一种架构设计模式。</li>
<li>Facade设计模式并非一个集装箱，可以任意地放进任何多个对象。Facade模式中组件的内部应该是“相互耦合关系比较大的一系列组件”，而不是一个简单的功能集合。</li>
</ul>
<hr>
<h4 id="6">Proxy 代理模式</h4>

<p>==<strong>动机</strong>==</p>
<p>在面向对象系统中，有些对象由于某种原因（比如对象创建的开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接的访问会给使用者、或者系统结构带来很多麻烦。如何在不是去透明操作对象的同事来管理/控制这些对象特有的负载型？</p>
<p>为其他对象提供一种代理以控制（隔离，使用接口）对这个对象的访问。</p>
<p>==<strong>要点总结</strong>==</p>
<ul>
<li>“增加一层间接层”是软件系统中对许多复杂问题的一种常见的解决方法。在面向对象系统中，直接使用某些对象会带来很多问题，作为间接层的Proxy对象便是解决这一问题的常用手段。</li>
<li>具体的proxy设计模式的实现方法、实现粒度都相差很大，有些可能对单个对象做细粒度的控制，如copy-on-write技术，有些可能对组件模块提供抽象代理层，在架构层次对对象做Proxy。</li>
<li>Proxy并不一定要求保持接口完整的一致性，只要能够实现间接控制，有时候损及一些透明性是可以接受的。</li>
</ul>
<hr>
<h4 id="7">Adapter 适配器模式</h4>


<p>==<strong>动机</strong>==</p>
<p>在软件系统中，由于应用环境的变化，常常需要将“一些现存的对象”放在新的环境中使用，但是新环境要求的接口是这些现存对象所不满足的。</p>
<p>将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<p>==<strong>要点总结</strong>==</p>
<ul>
<li>Adapter模式主要应用于“希望复用一些实现的类，但是接口又与复用环境要求不一致的情况”，在遗留代码复用和类库迁移时非常有用。</li>
</ul>
<p>GOF23 定义了两种Adapter模式的实现结构：</p>
<p>1) 对象适配器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classAdapter:publicITarget&#123;IAdaptee* pAdaptee;//非常灵活...                  &#125;</span><br></pre></td></tr></table></figure>

<p>非常灵活，pAdaptee可以指向任何可具体的实现类。</p>
<p>2) 类适配器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">classAdapter:publicITarget,//共有接口protectedIAdaptee</span><br><span class="line">&#123;//多继承，实现继承...                  &#125;</span><br></pre></td></tr></table></figure>

<p>不是很好，有局限性，如果IAdaptee仅仅是个接口，没有实现，如果换做具体类，那就没有了灵活性，一般不推荐使用。C++中可以，但是在JAVA等语言中不支持。</p>
<ul>
<li>Adapter模式可以实现的非常灵活，不必拘泥于GOF23中定义的两种结构。</li>
</ul>
<hr>
<h4 id="8">Mediator 中介者模式</h4>

<p>==<strong>动机</strong>==</p>
<p>在软件构建过程中，经常会出现多个对象互相关联交互的情况，对象之间常常会维持一种复杂的引用关系，如果遇到一些需求的更改，这种直接的引用关系将面临不断的变化。</p>
<p>用一个中介对象来封装（封装变化）一系列的对象交互。中介者使各对象不需要显式的相互引用（编译时依赖to运行时依赖），从而使其耦合松散（管理变化），而且可以独立的改变他们之间的交互。</p>
<p>==<strong>要点总结</strong>==</p>
<ul>
<li>将多个对象间复杂的关系关系解耦，Mediator模式将多个对象间的控制逻辑进行集中管理，变“多个对象互相关联”为“多个对象和一个中介者关联”，简化了系统的维护，抵御了可能的变化。</li>
<li>随着控制逻辑的复杂化，Mediator具体对象的实现可能相当复杂（复杂的消息机制）。这时候可以对Mediator对象进行分解处理。</li>
<li>Facade模式是解耦系统间（单向）的对象关联关系；Mediator模式是解耦系统内部各个对象之间（双向）的关联关系。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/11/cshe-ji-mo-shi-part-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Tang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IndigoAxe">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/11/cshe-ji-mo-shi-part-1/" itemprop="url">C++设计模式 part.1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-11T14:03:28+08:00">
                2018-07-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="#1">1. 设计模式简介</a><br><a href="#2">2. 面向对象设计原则</a><br><a href="#3">3. Template Method 模板方法模式</a><br><a href="#4">4. Strategy 策略模式</a><br><a href="#5">5. Observer/Event 观察者/事件模式</a><br><a href="#6">6. Decorator 装饰模式</a><br><a href="#7">7. Bridge 桥模式</a>  </p>
<h4 id="1">设计模式简介</h4>  
设计模式/软件设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。

<p><strong>设计模式的要点:</strong></p>
<ul>
<li>不断重复发生的问题  </li>
<li>解决方案的核心  </li>
<li>重复使用  </li>
</ul>
<p>设计模式和面向对象设计是分不开的，我们还要着重理解面向对象：</p>
<ul>
<li><p>向下，如何把握机器底层从微观理解对象构造  </p>
<ul>
<li>语言构造  </li>
<li>编译转换  </li>
<li>内存模型  </li>
<li>运行时机制  </li>
</ul>
</li>
<li><p>向上：如何将我们周围的世界抽象为程序代码  </p>
<ul>
<li>面向对象  </li>
<li>组件封装  </li>
<li>设计模式  </li>
<li>架构模式  </li>
</ul>
</li>
</ul>
<p><strong>深入理解面向对象：</strong> </p>
<ul>
<li><p>向下：三大面向对象机制</p>
<ul>
<li>封装，隐藏内部实现  </li>
<li>继承，复用现有代码  </li>
<li>多态，改写对象行为    </li>
</ul>
</li>
<li><p>向上：</p>
<ul>
<li>深刻把握面向对象机制所带来的抽象意义,理解如何使用这些机制来表达现实世界，掌握什么是“好的面向对象设计”</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2">面向对象设计原则</h4>  
**变化是复用的天敌。**而面向对象的优势就在于**抵御变化**。  
为了抵御变化，我们要程序设计中使用合适的设计模式。

<p><strong>重新认识面向对象：</strong><br>隔离变化：能将变化所带来的影响减到最小。<br>各司其职：面向对象的方式强调个各类的“职责”，新增加的类不会影响原有类。<br><strong>对象是什么？</strong><br>语言：对象封装了代码和数据。<br>规格：对象是一系列可被使用的公共接口。<br>概念：对象是某种拥有责任的抽象。  </p>
<p>为什么要提倡“Design Pattern呢？根本原因是为了代码复用，增加可维护性。那么怎么才能实现代码复用呢？面向对象有几个原则：单一职责原则 （Single Responsiblity Principle SRP）开闭原则（Open Closed Principle，OCP）、里氏代换原则（Liskov Substitution Principle，LSP）、依赖倒置原则（Dependency Inversion Principle，DIP）、接口隔离原则（Interface Segregation Principle，ISP）、合成/聚合复用原则（Composite/Aggregate Reuse Principle，CARP）、最小知识原则（Principle of Least Knowledge，PLK，也叫迪米特法则）。开闭原则具有理想主义的色彩，它是面向对象设计的终极目标。其他几条，则可以看做是开闭原则的实现方法。<br>设计模式就是实现了这些原则，从而达到了代码复用、增加可维护性的目的。下面是这几个原则的一些简单介绍：</p>
<ol>
<li><p>依赖倒置原则（DIP）<br>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</p>
</li>
<li><p>开闭原则（OCP）<br>对拓展开放，对更改封闭。<br>在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。<br>因此，当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</p>
</li>
<li><p>单一职责原则（SRP）<br>类的职责要单一，不能将太多的职责放在一个类中。（高内聚、低耦合）<br>功能单一便于使用和维护，并且不会发生太多干扰。</p>
</li>
<li><p>Liskor替换原则（LSP）<br>子类必须能替换他的基类。</p>
</li>
<li><p>接口隔离原则（ISP）<br>客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。</p>
</li>
<li><p>优先使用对象组合，而不是类继承<br>继承为白箱复用，某种程度上为打破了封装性，耦合度高。<br>利用对象组合则拥有良好定义的接口，耦合度低。</p>
</li>
<li><p>封装变化点<br>使用封装来创建对象间的分界层。让设计可以在分界层一侧进行修改，而不影响另一侧。实现层次间的松耦合。</p>
</li>
<li><p>针对接口编程，而不是针对实现编程<br>不将变量类型设置为具体的类，而是声明为接口。这样客户无需知道对象的具体类型，而只需知道对象具有的接口，减少各部分的依赖关系，实现“高内聚，低耦合”的设计思想。</p>
</li>
</ol>
<p><strong>重构获得模式 Refactoring to Patterns</strong>  </p>
<ul>
<li>应对变化，提高复用  </li>
<li>发现变化，在变化点处应用设计模式。什么时候、什么地点应用设计模式比理解设计模式结构本身更为重要  </li>
<li>设计模式应用不宜先入为主。没有一步到位的设计模式。  </li>
</ul>
<p><strong>重构关键技巧(其实下面几点归根结底都是同一个本质)：</strong></p>
<p>静态 -&gt; 动态<br>早绑定 -&gt; 晚绑定<br>继承 -&gt; 组合<br>编译器依赖 -&gt; 运行时依赖<br>紧耦合 -&gt; 松耦合  </p>
<hr>
<h4 id="3">Template Method 模板方法模式</h4>    

<p>在软件构件过程中，对于某一项任务，它常常有稳定的整体操作结构，但是个个自步骤却有很多改变的需求，或者由于固有的原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现。<br>定义一个操作中的算法的<strong>骨架（稳定）</strong>，而将一些步骤<strong>延迟（变化）</strong>到子类中。Template Method使得子类可以<strong>不改变（复用）</strong>一个算法的结构即可<strong>重定义（override重写）</strong>该算法的某些特定步骤。</p>
<p><strong>要点总结：</strong>  </p>
<ul>
<li>Template Method模式是一种非常基础性的设计模式，在面向对象系统中有着大量的应用。使用虚函数的多态性为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本实现结构。  </li>
<li>除了可以灵活对子步骤的变化外，“不要调用我，让我来调用你”的反向控制结构是Template Method的典型应用。  </li>
<li>在实现时，被Template Method调用的虚方法可以具有实现，也可以没有任何实现（抽象方法、纯虚方法），但一般推荐将他们设置为protected方法。</li>
</ul>
<hr>
<h4 id="4">Strategy 策略模式</h4>  

<p>在软件构件过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常负责，而且有时候支持不适用的算法也是一个性能负担。<br>定义一系列算法，把他们一个个封装起来，并且使他们可以<strong>相互替换（变化）</strong>，该模式使得算法可独立于使用它的客户程序<strong>（稳定）而变化（扩展，子类化）</strong>。</p>
<p><strong>要点总结</strong>  </p>
<ul>
<li>Strategy及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换。</li>
<li>Strategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需要使用Strategy模式。</li>
<li>如果Strategy对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省对象开销。</li>
</ul>
<hr>
<h4 id="5">Observer/Event 观察者/事件模式</h4>  
在软件构建过程中，我们需要为某些对象建立一种**“通知依赖关系”** —— 一个对象（目标对象）的状态发生改变，所有的**依赖对象（观察者对象）都将得到通知**。
定义对象间的**一种一对多（变化）的依赖关系**，以便当一个对象（Subject）的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。  

<p><strong>要点总结</strong></p>
<ul>
<li>使用面向对象的抽象，Observer模式使得我们可以独立地改变（改变时，两者不相互影响）目标与观察者，从而使二者之间的依赖关系松耦合。</li>
<li>目标发送通知时，无需指定观察者，通知（可以携带通知信息作为参数）会自动传播。</li>
<li>观察者自己决定是否需要订阅通知，目标对象对此一无所知。</li>
<li><strong>Observer模式是基于事件的UI框架中非常常用的设计模式，是MVC的一个重要组成部分。</strong></li>
</ul>
<hr>
<h4 id="6">Decorator 装饰模式</h4>  
在某些情况下，我们可能会“过度的使用继承来扩展对象的功能”，由于继承为类型引入的静态特性，使得这种扩展方式缺少灵活性，并且随着子类的增多，各种子类的组合会导致更多子类的膨胀。
动态（组合）的给一个对象增加一些额外的职责，就增加功能而言，Decorator模式比生成子类（继承）更为灵活（消除重复代码&减少子类个数）。

<p><strong>要点总结</strong>  </p>
<ul>
<li>通过组合而非继承的手法，Decorator模式实现了在运行时动态扩展对象功能的能力，可根据需要扩展多个功能。避免了使用继承带来的“灵活性差”和“多子类衍生问题”。</li>
<li>Decorator类在接口上表现为is-a Component的继承关系，即Decorator类继承了Component类的所有接口。但是在实现上又表现为has-a Component的组合关系，即Decorator类又使用了另一个Component类。</li>
<li>Decorator模式的目的并非解决“多子类衍生的多继承”问题，其要点在于解决“主体类在多个方向上的扩展功能”—-是为“装饰”的含义。</li>
</ul>
<hr>
<h4 id="7">Bridge 桥模式</h4>  

<p>由于某些类型的固有的实现逻辑，使得它们具有连个变化的维度，乃至多个维度的变化。<br>为了应对这种多维度的变化，我们需要利用面向对象技术来是的类型可以轻松地沿着两个乃至于多个方向变化，而不引入额外的复制维度。这时候我们就需要使用桥模式：</p>
<blockquote>
<p>将抽象部分（业务功能）与实现部分（平台实现）分离，使它们都可以独立的变化。<br>           –《设计模式》GoF</p>
</blockquote>
<p><strong>要点总结:</strong></p>
<ul>
<li>Bridge模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度变化（子类）。所谓抽象和实现沿着各自纬度的变化，即“子类化”它们。</li>
<li>Bridge模式有时候类似于多继承方案，但是多继承方案往往违背单一职责原则（即一个类只有一个变化的原因），复用性较差。Bridge模式是比多继承方案更好的解决方案。</li>
<li>Bridge模式的应用一般在“两个非常强的变化维度”，有时候一个类也有多于两个的变化纬度，这时可以使用Bridge的扩展模式。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/04/stlyu-fan-xing-bian-cheng-part-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Tang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IndigoAxe">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/04/stlyu-fan-xing-bian-cheng-part-3/" itemprop="url">STL与泛型编程part.3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-04T16:32:14+08:00">
                2018-07-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="#1">1. 泛型算法的结构</a><br><a href="#2">2. 算法的命名规范</a><br><a href="#3">3. 容器特有的算法</a><br><a href="#4">4. STL的内存分配器</a><br><a href="#5">5. 分配算法</a><br><a href="#6">6. 内存分配器小结</a></p>
<h4 id="1">泛型算法的结构</h4>

<p>   就像所有的容器都建立在一致的设计模式上一样，算法也具有共同的设计基础。</p>
<p>   算法最基本的性质是需要使用的迭代器种类。<br>   另一种算法分类方法是前面介绍的按实现的功能分类：只读算法，不改变元素的值和顺序；给指定元素赋新值的算法；将一个元素的值移给另一个元素的算法。<br>   另外，算法还有两种结构上的算法模式：一种模式是由算法所带的形参定义；另一种模式则通过两种函数命名和重载的规范定义。</p>
<p>算法的形参模式</p>
<p>   大多数算法采用下面四种形式之一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alg (beg, end, other parms);</span><br><span class="line">alg (beg, end, dest, other parms);</span><br><span class="line">alg (beg, end, beg2, other parms);</span><br><span class="line">alg (beg, end, beg2, end2, other parms);</span><br></pre></td></tr></table></figure>

<p>其中，alg是算法名，[beg, end)是输入范围，beg, end, dest, beg2, end2都是迭代器。</p>
<p>   对于带有单个目标迭代器的算法：dest形参是一个迭代器，用于指定存储输出数据的目标对象。算法假定无论需要写入多少个元素都是安全的。注意：调用这类算法时，算法是将输出内容写到容器中已存在的元素上，所以必须确保输出容器中有足够大的容量存储输出数据，这也正是通过使用插入迭代器或者ostream_iterator来调用这些算法的原因。</p>
<p>   对于带第二个输入序列的算法：beg2和end2标记了完整的输出范围。而只有beg2的算法将beg2视为第二个输入范围的首元素，算法假定以beg2开始的范围至少与beg和end指定的范围一样大。</p>
<h4 id="2">算法的命名规范</h4>

<p>   包括两种重要模式：第一种模式包括测试输入范围内元素的算法，第二种模式则应用于输入范围内元素的重新排序的算法。</p>
<p>   1）区别带有一个值或一个谓词函数参数的算法版本</p>
<p>   很多算法通过检查其输入范围内的元素实现其功能。这些算法通常要用到标准关系操作符：<code>==</code> 或 <code>&lt;</code> 。其中的大部分算法都提供了第二个版本的算法，允许程序员提供比较或测试函数取代默认的操作符的使用。</p>
<p>   例如， 排序算法默认使用 &lt; 操作符，其重载版本带有一个额外的形参，表示取代默认的 &lt; 操作符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sort (beg, end);         // use &lt; operator to sort the elements</span><br><span class="line">sort (beg, end, comp);   // use function named comp to sort the elements</span><br></pre></td></tr></table></figure>


<p>   又如，查找算法默认使用 == 操作符。标准库为这类算法提供另外命名的（而非重载的）版本，带有谓词函数形参。对于带有谓词函数形参的算法，其名字带有后缀 _if：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find (beg, end, val);      // find first instance of val in the input range</span><br><span class="line">find_if (beg, end, pred);  // find first instance for which pred is true</span><br></pre></td></tr></table></figure>

<p>标准库为这类算法提供另外命名的版本，而非重载版本，原因在于这两种版本的算法带有相同的参数个数，容易导致二义性。</p>
<p>   2）区别是否实现复制的算法版本</p>
<p>   默认情况下，算法将重新排列的写回其范围。标准库也为这类算法提供了另外命名的版本，将元素写到指定的输出目标。此版本的算法在名字中添加 _copy后缀，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reverse (beg, end);</span><br><span class="line">reverse_copy (beg, end, dest);</span><br></pre></td></tr></table></figure>

<p>第一个版本将输入序列中的元素反向重新排列；而第二个版本将复制输入序列中的元素，并将它们以逆序存储到dest开始的序列中。</p>
<h4 id="3">容器特有的算法</h4>  

<p>   list容器上的迭代器是双向的，而不是随机访问类型。由于list容器不支持随机访问，因此，在此容器上不能使用需要随机访问迭代器的算法。如sort类算法。其它有些算法，如merge, remove, reverse, unique等，虽然可以用在list上，但性能太差。list容器结合自己的结构专门实现了更为高效的算法。因此，对于list对象，应该优先使用list容器特有的成员版本，而不是泛型算法。</p>
<p>   list容器特有的算法与其泛型算法版本之间有两个重要的差别：1）remove和unique的list版本修改了其关联的基础容器：真正删除了指定的元素；2）list容器提供的merge和splice操作会破坏它们的实参。使用泛型算法的merge版本，合并的序列将写入目标迭代器指向的对象，而它的两个输入序列保持不变。</p>
<h4 id="4">STL的内存分配器</h4>

<p>隐藏在STL的容器后的内存管理工作是通过STL提供的一个默认的allocator实现的。当然，用户也可以定制自己的allocator，只要实现allocator模板所定义的接口方法即可，然后通过将自定义的allocator作为模板参数传递给STL容器，创建一个使用自定义allocator的STL容器对象，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stl::vector&lt;int, UserDefinedAllocator&gt; array;</span><br></pre></td></tr></table></figure>

<p>大多数情况下，STL默认的allocator就已经足够了。这个allocator是一个由两级分配器构成的内存管理器，当申请的内存大小大于128byte时，就启动第一级分配器通过malloc直接向系统的堆空间分配，如果申请的内存大小小于128byte时，就启动第二级分配器，从一个预先分配好的内存池中取一块内存交付给用户，这个内存池由16个不同大小（8的倍数，8~128byte）的空闲列表组成，allocator会根据申请内存的大小（将这个大小round up成8的倍数）从对应的空闲块列表取表头块给用户。</p>
<p>这种做法有两个优点：</p>
<p>1）小对象的快速分配。小对象是从内存池分配的，这个内存池是系统调用一次malloc分配一块足够大的区域给程序备用，当内存池耗尽时再向系统申请一块新的区域，整个过程类似于批发和零售，起先是由allocator向总经商批发一定量的货物，然后零售给用户，与每次都总经商要一个货物再零售给用户的过程相比，显然是快捷了。当然，这里的一个问题时，内存池会带来一些内存的浪费，比如当只需分配一个小对象时，为了这个小对象可能要申请一大块的内存池，但这个浪费还是值得的，况且这种情况在实际应用中也并不多见。</p>
<p>2）避免了内存碎片的生成。程序中的小对象的分配极易造成内存碎片，给操作系统的内存管理带来了很大压力，系统中碎片的增多不但会影响内存分配的速度，而且会极大地降低内存的利用率。以内存池组织小对象的内存，从系统的角度看，只是一大块内存池，看不到小对象内存的分配和释放。</p>
<p>实现时，allocator需要维护一个存储16个空闲块列表表头的数组free_list，数组元素i是一个指向块大小为8*(i+1)字节的空闲块列表的表头，一个指向内存池起始地址的指针start_free和一个指向结束地址的指针end_free。空闲块列表节点的结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">union obj &#123;</span><br><span class="line">    union obj *free_list_link;</span><br><span class="line">    char client_data[1];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个结构可以看做是从一个内存块中抠出4个字节大小来，当这个内存块空闲时，它存储了下个空闲块，当这个内存块交付给用户时，它存储的时用户的数据。因此，allocator中的空闲块链表可以表示成<br><code>obj* free_list[16];</code></p>
<h4 id="5">分配算法</h4>

<p>allocator分配内存的算法如下：</p>
<p>算法：allocate<br>输入：申请内存的大小size<br>输出：若分配成功，则返回一个内存的地址，否则返回NULL  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if(size大于128）&#123; 启动第一级分配器直接调用malloc分配所需的内存并返回内存地址；&#125;</span><br><span class="line"></span><br><span class="line">    else &#123;</span><br><span class="line"></span><br><span class="line">        将size向上round up成8的倍数并根据大小从free_list中取对应的表头free_list_head;</span><br><span class="line"></span><br><span class="line">        if(free_list_head不为空）&#123;</span><br><span class="line"></span><br><span class="line">              从该列表中取下第一个空闲块并调整free_list；</span><br><span class="line"></span><br><span class="line">              返回free_list_head;</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line"></span><br><span class="line">             调用refill算法建立空闲块列表并返回所需的内存地址；</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法： refill<br>输入：内存块的大小size<br>输出：建立空闲块链表并返回第一个可用的内存块地址    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">     调用chunk_alloc算法分配若干个大小为size的连续内存区域并返回起始地址chunk和成功分配的块数nobj；</span><br><span class="line"></span><br><span class="line">    if(块数为1)直接返回chunk；</span><br><span class="line"></span><br><span class="line">    否则</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">         开始在chunk地址块中建立free_list;</span><br><span class="line"></span><br><span class="line">         根据size取free_list中对应的表头元素free_list_head;</span><br><span class="line"></span><br><span class="line">         将free_list_head指向chunk中偏移起始地址为size的地址处, 即free_list_head=(obj*)(chunk+size);</span><br><span class="line"></span><br><span class="line">         再将整个chunk中剩下的nobj-1个内存块串联起来构成一个空闲列表；</span><br><span class="line"></span><br><span class="line">         返回chunk，即chunk中第一块空闲的内存块；</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>算法：chunk_alloc<br>输入：内存块的大小size，预分配的内存块块数nobj(以引用传递)<br>输出：一块连续的内存区域的地址和该区域内可以容纳的内存块的块数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">      计算总共所需的内存大小total_bytes；</span><br><span class="line"></span><br><span class="line">      if(内存池中足以分配，即end_free - start_free &gt;= total_bytes) &#123;</span><br><span class="line"></span><br><span class="line">          则更新start_free;</span><br><span class="line"></span><br><span class="line">          返回旧的start_free;</span><br><span class="line"></span><br><span class="line">      &#125; else if(内存池中不够分配nobj个内存块，但至少可以分配一个)&#123;</span><br><span class="line"></span><br><span class="line">         计算可以分配的内存块数并修改nobj；</span><br><span class="line"></span><br><span class="line">         更新start_free并返回原来的start_free;</span><br><span class="line"></span><br><span class="line">      &#125; else &#123; //内存池连一块内存块都分配不了</span><br><span class="line"></span><br><span class="line">         先将内存池的内存块链入到对应的free_list中后；</span><br><span class="line"></span><br><span class="line">         调用malloc操作重新分配内存池，大小为2倍的total_bytes加附加量，start_free指向返回的内存地址；</span><br><span class="line"></span><br><span class="line">         if(分配不成功) &#123;</span><br><span class="line"></span><br><span class="line">             if(16个空闲列表中尚有空闲块）</span><br><span class="line"></span><br><span class="line">                尝试将16个空闲列表中空闲块回收到内存池中再调用chunk_alloc(size, nobj)；</span><br><span class="line"></span><br><span class="line">            else &#123;</span><br><span class="line"></span><br><span class="line">                   调用第一级分配器尝试out of memory机制是否还有用；</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         更新end_free为start_free+total_bytes，heap_size为2倍的total_bytes;</span><br><span class="line"></span><br><span class="line">         调用chunk_alloc(size,nobj);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>算法：deallocate<br>输入：需要释放的内存块地址p和大小size</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if(size大于128字节）直接调用free(p)释放；</span><br><span class="line"></span><br><span class="line">    else&#123;</span><br><span class="line"></span><br><span class="line">        将size向上取8的倍数，并据此获取对应的空闲列表表头指针free_list_head;</span><br><span class="line"></span><br><span class="line">       调整free_list_head将p链入空闲列表块中；</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6">内存分配器小结</h4>

<p>STL中的内存分配器实际上是基于空闲列表(free list)的分配策略，最主要的特点是通过组织16个空闲列表，对小对象的分配做了优化。</p>
<p>1）小对象的快速分配和释放。当一次性预先分配好一块固定大小的内存池后，对小于128字节的小块内存分配和释放的操作只是一些基本的指针操作，相比于直接调用malloc/free，开销小。</p>
<p>2）避免内存碎片的产生。零乱的内存碎片不仅会浪费内存空间，而且会给OS的内存管理造成压力。</p>
<p>3）尽可能最大化内存的利用率。当内存池尚有的空闲区域不足以分配所需的大小时，分配算法会将其链入到对应的空闲列表中，然后会尝试从空闲列表中寻找是否有合适大小的区域，</p>
<p>但是，这种内存分配器局限于STL容器中使用，并不适合一个通用的内存分配。因为它要求在释放一个内存块时，必须提供这个内存块的大小，以便确定回收到哪个free list中，而STL容器是知道它所需分配的对象大小的，比如上述：<br><code>stl::vector&lt;int&gt; array;</code><br>array是知道它需要分配的对象大小为sizeof(int)。一个通用的内存分配器是不需要知道待释放内存的大小的，类似于free(p)。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/27/stlyu-fan-xing-bian-cheng-part-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Tang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IndigoAxe">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/27/stlyu-fan-xing-bian-cheng-part-2/" itemprop="url">STL与泛型编程part.2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-27T14:00:59+08:00">
                2018-06-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="#1">1. STL整体结构</a><br><a href="#2">2. 仿函数，仿函数适配器</a><br><a href="#3">3. 其他需要注意的问题</a><br><a href="#4">4. 泛型算法</a>    </p>
<hr>
<h4 id="1">STL整体结构</h4>
> 转自百度百科：  
从根本上说，STL是一些“容器”的集合，这些“容器”有list,vector,set,map等，STL也是算法和其他一些组件的集合。这里的“容器”和算法的集合指的是世界上很多聪明人很多年的杰作。STL的目的是标准化组件，这样就不用重新开发，可以使用现成的组件。STL现在是C++的一部分，因此不用额外安装什么。

<p>STL主要由六部分组成，分别为容器(containers)、迭代器(iterators)、空间配置器(allocator)、配接器(adapters)、算法(algorithms)、仿函数(functors)。<br>它们之间的关系如下：  </p>
<ul>
<li>容器通过内存分配器分配空间</li>
<li>容器和算法分离</li>
<li>算法通过迭代器访问容器</li>
<li>仿函数协助算法完成不同的策略变化</li>
<li>适配器套接仿函数</li>
</ul>
<hr>
<h4 id="2">仿函数，仿函数适配器</h4>

<p><strong>仿函数</strong>又称为函数对象（Function Object），其作用相当于一个函数指针。<br>在STL中，将<code>std::remove_if(v.begin().v.end(),ContainsString(L&quot;C++&quot;));</code>中类似于<code>ConstainString</code>这种形为函数指针的对象定义为仿函数，其实它是一个重载了括号运算符的Class。因此，自定义的仿函数必须重载<code>operator()</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct ContainString: </span><br><span class="line">public std::unary_function&lt;std::wstring, bool&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ConstainString(const std::wstring&amp; wszMatch): </span><br><span class="line">        m_wszMatch(wszMatch)&#123;&#125;</span><br><span class="line">    bool operator()(const std::wstring&amp; wszStringToMatch) const</span><br><span class="line">    &#123;</span><br><span class="line">        return (wszStringToMatch.find(m_wszMatch)!=-1);</span><br><span class="line">    &#125;</span><br><span class="line">    std::wstring m_wszMatch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仿函数存在的意义：  </p>
<ol>
<li>普通函数指针不能满足STL的抽象要求（参数和返回型别的定义问题）</li>
<li>函数指针无法和STL其他组件交互</li>
<li>仿函数可以作为模板实参来定义对象的某种默认行为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//定义set的默认排序行为</span><br><span class="line">template&lt;typename _Kty, typename _pr = less&lt;_Kty&gt;,...&gt;</span><br><span class="line">class set&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>仿函数适配器</strong>。STL提供三种适配器：改变容器接口的容器适配器、改变迭代器接口的迭代器适配器以及改变仿函数接口的<strong>仿函数适配器</strong>。前两者都较为简单，而最后一种则是灵活性最大的，有了它我们可以构造非常复杂的表达式策略。</p>
<p>在一些情况下仿函数可能无法匹配成合适的型别，这个时候我们就需要使用仿函数适配器：binder1st/binder2nd, mem_fun/men_fun_ref。例如，在一个给定的vector<int>中寻找不为零的元素。通常我们会想到使用<code>std::not_equal_to</code>这个仿函数，但是该函数接受两个参数。为了能在<code>std::find_if</code>中使用这个函数，我们这时候就需要绑定其中一个变量为0，以实现判断一个元素是否不为零的功能：</int></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt;::iterator it = std::find_if(v.begin(),v.end(),</span><br><span class="line">          std::bind1st(std::not_equal_to&lt;int&gt;(),0));</span><br><span class="line">//bind1st 封装了binder1st的调用复杂性：</span><br><span class="line">template&lt;class _Fn2, class_Ty&gt;</span><br><span class="line">inline binder1st&lt;_Fn2&gt; bind1st(const _Fn2&amp; _Func,const _Ty&amp; _Left)</span><br><span class="line">&#123;</span><br><span class="line">    typename _Fn2::first_argument_type_Val(_Left);</span><br><span class="line">     return (binder1st&lt;_Fn2&gt;(_Func,_Val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于类的成员函数的适配，我们可以使用mem_fun/mem_fun_ref：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">template &lt;_Result, class _Ty&gt; inline</span><br><span class="line">mem_fun_t&lt;_Result,_Ty&gt; mem_fun(_Result (_Ty::*_Pm)() )</span><br><span class="line">&#123;</span><br><span class="line">    return (mem_fun_t&lt;_Result, _Ty&gt;(_Pm));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class _Result, class _Ty&gt;</span><br><span class="line">class mem_fun_t : public unar_function&lt;_Ty *, _Result&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    explicit mem_fun_t(_Result (_Ty::*_Pm)())</span><br><span class="line">        : _Pmemfun(_Pm)  &#123; &#125;</span><br><span class="line">    _Result operator()(_Ty *_Pleft) const</span><br><span class="line">    &#123;</span><br><span class="line">        return ((_Pleft-&gt;*_Pmemfun)());</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    _Result (_Ty::*_Pmemfun());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3">其他需要注意的问题</h4>

<p>(1) 单线程情况下涉及对字符串的操作，首选std::string/wstring。<br>    多线程情况下要注意string是否带引用计数。在多线程环境下，避免分配和拷贝所节省下的开销转嫁到了并发控制上。一般考虑使用vector<char>/vector<wchar_t>，因为vector的实现是不带引用计数的。</wchar_t></char></p>
<p>(2) 当用new创建的对象直接放入容器时，要在销毁容器前delete那些对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v.push_back(new Person(&quot;TOM&quot;,1));</span><br><span class="line">...</span><br><span class="line">for(vector&lt;Person *&gt;::iterator it = v.begin(); it!=v.end();it++)</span><br><span class="line">&#123;</span><br><span class="line">    delete (*it);</span><br><span class="line">&#125;</span><br><span class="line">v.clear();</span><br></pre></td></tr></table></figure>

<p>(3)尽量使用算法调用代替手写循环，如上面的删除，我们可以定义一个仿函数在for_each中实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct DeleteElement&#123;</span><br><span class="line">    template &lt;typename TElement&gt;</span><br><span class="line">    void operator() (const TElement* p) const </span><br><span class="line">    &#123;</span><br><span class="line">        delete p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::for_each(v.begin(),v.end(),DeleteElement());</span><br></pre></td></tr></table></figure>

<p>(4) 可以通过swap为容器“缩水”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt;(v).swap(v);//使capacity = size</span><br><span class="line">std::vector&lt;int&gt;().swap(v) //清除v并最小化其容量:capacity = size = 0</span><br></pre></td></tr></table></figure>

<p>(5) 在有对象继承的情况下，建立指针的容器，而不是对象的容器。因为：a）容器装入的对象是原始对象的拷贝，如果对象很大，则有较大性能开销；b）由于继承的存在，拷贝会发生slicing，导致丢失数据。</p>
<hr>
<h4 id="3">泛型算法</h4>

<p>简单列出STL为我们提供的算法：  </p>
<p><strong>非变易性算法</strong><br>for_each 提供对于容器内每个元素进行循环操作<br>find 线性查找<br>find_fist_of 对于给定值的集合,在容器内线性查找<br>adjacent_find 线性查找邻近且相等的元素对<br>count 计算给定值的出现次数<br>mismatch 比较两个序列,找出第一个不相同元素的位置<br>equal 两个序列的判等操作,逐一比较元素是否相等<br>search 在一个序列中查找与另一个序列匹配的子序列<br>search_n 在序列中查找一系列符合给定值的元素<br>find_end 在一个序列中查找最后一个与另一个序列匹配的子序列 </p>
<p><strong>变易性算法</strong><br>copy 复制元素到另外一个序列<br>swap 两个容器元素交换<br>transform 序列中的元素都用这个元素变换后的值代替<br>replace 替换给定值的元素<br>fill 填充给定值的元素<br>generate 用某函数的返回值来代替序列中的所有元素<br>remove 删除序列中等于某一给定之的所有元素<br>unique 删除所有连续相等的元素<br>reverse 将元素之间的位置关系取逆<br>rotate 循环移动序列中的元素<br>random_shuffle 随机排列元素<br>partition 按某一顺序重新排列元素 </p>
<p><strong>有序队列算法</strong><br>sort,stable_sort,partial_sort 对元素排序<br>nth_element 查找第n个大的元素<br>binary_search lower_bound upper_bound equal_range 用二分查找搜索有序队列<br>merge 归并两个有序队列<br>includes set_union set_intersection set_difference set_sysmetric_difference 集合运算<br>push_heap pop_heap make_heap sort_heap 堆操作<br>min max min_element max_element 求最大,最小元素<br>lexicographical_compare 字典序比较<br>next_permutation prev_permutation 依据字典序生成排列 </p>
<p><strong>通用数字算法</strong><br>accumulate 累加<br>inner_product 内积<br>partial_sum 累加部分元素<br>adjacent_difference 计算相邻元素的差,保存在另一个序列中 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Alex Tang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alex Tang</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
